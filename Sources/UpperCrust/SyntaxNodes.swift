/// SyntaxNodes.swift
/// Automatically generated by SyntaxGen. Do not edit!
///
/// Copyright 2017, The Silt Language Project.
///
/// This project is released under the MIT license, a copy of which is
/// available in the repository.
public class ExprSyntax: Syntax {}
public class DeclSyntax: Syntax {}
public class IdentifierListSyntax: SyntaxCollection<TokenSyntax> {
  public override class var kind: SyntaxKind {
    return .identifierList
  }
}

public class QualifiedNameSyntax: SyntaxCollection<QualifiedNamePieceSyntax> {
  public override class var kind: SyntaxKind {
    return .qualifiedName
  }
}

public class QualifiedNamePieceSyntax: Syntax {
  public enum Cursor: Int {
    case name
    case trailingPeriod
  }

  public convenience init(name: TokenSyntax, trailingPeriod: TokenSyntax?) {
    let raw = RawSyntax.node(.qualifiedNamePiece, [
      name.raw,
      trailingPeriod?.raw ?? RawSyntax.missingToken(.period),
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var name: TokenSyntax {
    return child(at: Cursor.name) as! TokenSyntax
  }
  public func withName(_ syntax: TokenSyntax) -> QualifiedNamePieceSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.name)
  }

  public var trailingPeriod: TokenSyntax? {
    return child(at: Cursor.trailingPeriod) as? TokenSyntax
  }
  public func withTrailingPeriod(_ syntax: TokenSyntax) -> QualifiedNamePieceSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.trailingPeriod)
  }

}

public class ModuleDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case moduleToken
    case moduleIdentifier
    case typedParameterList
    case whereToken
    case declList
  }

  public convenience init(moduleToken: TokenSyntax, moduleIdentifier: TokenSyntax, typedParameterList: TypedParameterListSyntax?, whereToken: TokenSyntax, declList: DeclListSyntax) {
    let raw = RawSyntax.node(.moduleDecl, [
      moduleToken.raw,
      moduleIdentifier.raw,
      typedParameterList?.raw ?? RawSyntax.missing(.typedParameterList),
      whereToken.raw,
      declList.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var moduleToken: TokenSyntax {
    return child(at: Cursor.moduleToken) as! TokenSyntax
  }
  public func withModuleToken(_ syntax: TokenSyntax) -> ModuleDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.moduleToken)
  }

  public var moduleIdentifier: TokenSyntax {
    return child(at: Cursor.moduleIdentifier) as! TokenSyntax
  }
  public func withModuleIdentifier(_ syntax: TokenSyntax) -> ModuleDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.moduleIdentifier)
  }

  public var typedParameterList: TypedParameterListSyntax? {
    return child(at: Cursor.typedParameterList) as? TypedParameterListSyntax
  }
  public func withTypedParameterList(_ syntax: TypedParameterListSyntax) -> ModuleDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.typedParameterList)
  }

  public var whereToken: TokenSyntax {
    return child(at: Cursor.whereToken) as! TokenSyntax
  }
  public func withWhereToken(_ syntax: TokenSyntax) -> ModuleDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.whereToken)
  }

  public var declList: DeclListSyntax {
    return child(at: Cursor.declList) as! DeclListSyntax
  }
  public func withDeclList(_ syntax: DeclListSyntax) -> ModuleDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.declList)
  }

}

public class DeclListSyntax: SyntaxCollection<DeclSyntax> {
  public override class var kind: SyntaxKind {
    return .declList
  }
}

public class OpenImportDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case openToken
    case importToken
    case importIdentifier
  }

  public convenience init(openToken: TokenSyntax?, importToken: TokenSyntax, importIdentifier: TokenSyntax) {
    let raw = RawSyntax.node(.openImportDecl, [
      openToken?.raw ?? RawSyntax.missingToken(.openKeyword),
      importToken.raw,
      importIdentifier.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var openToken: TokenSyntax? {
    return child(at: Cursor.openToken) as? TokenSyntax
  }
  public func withOpenToken(_ syntax: TokenSyntax) -> OpenImportDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.openToken)
  }

  public var importToken: TokenSyntax {
    return child(at: Cursor.importToken) as! TokenSyntax
  }
  public func withImportToken(_ syntax: TokenSyntax) -> OpenImportDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.importToken)
  }

  public var importIdentifier: TokenSyntax {
    return child(at: Cursor.importIdentifier) as! TokenSyntax
  }
  public func withImportIdentifier(_ syntax: TokenSyntax) -> OpenImportDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.importIdentifier)
  }

}

public class ImportDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case importToken
    case importIdentifier
  }

  public convenience init(importToken: TokenSyntax, importIdentifier: TokenSyntax) {
    let raw = RawSyntax.node(.importDecl, [
      importToken.raw,
      importIdentifier.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var importToken: TokenSyntax {
    return child(at: Cursor.importToken) as! TokenSyntax
  }
  public func withImportToken(_ syntax: TokenSyntax) -> ImportDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.importToken)
  }

  public var importIdentifier: TokenSyntax {
    return child(at: Cursor.importIdentifier) as! TokenSyntax
  }
  public func withImportIdentifier(_ syntax: TokenSyntax) -> ImportDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.importIdentifier)
  }

}

public class DataDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case dataToken
    case dataIdentifier
    case typedParameterList
    case typeIndices
    case whereToken
    case constructorList
  }

  public convenience init(dataToken: TokenSyntax, dataIdentifier: TokenSyntax, typedParameterList: TypedParameterListSyntax?, typeIndices: TypeIndicesSyntax, whereToken: TokenSyntax, constructorList: ConstructorListSyntax) {
    let raw = RawSyntax.node(.dataDecl, [
      dataToken.raw,
      dataIdentifier.raw,
      typedParameterList?.raw ?? RawSyntax.missing(.typedParameterList),
      typeIndices.raw,
      whereToken.raw,
      constructorList.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var dataToken: TokenSyntax {
    return child(at: Cursor.dataToken) as! TokenSyntax
  }
  public func withDataToken(_ syntax: TokenSyntax) -> DataDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.dataToken)
  }

  public var dataIdentifier: TokenSyntax {
    return child(at: Cursor.dataIdentifier) as! TokenSyntax
  }
  public func withDataIdentifier(_ syntax: TokenSyntax) -> DataDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.dataIdentifier)
  }

  public var typedParameterList: TypedParameterListSyntax? {
    return child(at: Cursor.typedParameterList) as? TypedParameterListSyntax
  }
  public func withTypedParameterList(_ syntax: TypedParameterListSyntax) -> DataDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.typedParameterList)
  }

  public var typeIndices: TypeIndicesSyntax {
    return child(at: Cursor.typeIndices) as! TypeIndicesSyntax
  }
  public func withTypeIndices(_ syntax: TypeIndicesSyntax) -> DataDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.typeIndices)
  }

  public var whereToken: TokenSyntax {
    return child(at: Cursor.whereToken) as! TokenSyntax
  }
  public func withWhereToken(_ syntax: TokenSyntax) -> DataDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.whereToken)
  }

  public var constructorList: ConstructorListSyntax {
    return child(at: Cursor.constructorList) as! ConstructorListSyntax
  }
  public func withConstructorList(_ syntax: ConstructorListSyntax) -> DataDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.constructorList)
  }

}

public class TypeIndicesSyntax: Syntax {
  public enum Cursor: Int {
    case colonToken
    case indexExpr
  }

  public convenience init(colonToken: TokenSyntax, indexExpr: ExprSyntax) {
    let raw = RawSyntax.node(.typeIndices, [
      colonToken.raw,
      indexExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var colonToken: TokenSyntax {
    return child(at: Cursor.colonToken) as! TokenSyntax
  }
  public func withColonToken(_ syntax: TokenSyntax) -> TypeIndicesSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.colonToken)
  }

  public var indexExpr: ExprSyntax {
    return child(at: Cursor.indexExpr) as! ExprSyntax
  }
  public func withIndexExpr(_ syntax: ExprSyntax) -> TypeIndicesSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.indexExpr)
  }

}

public class TypedParameterListSyntax: SyntaxCollection<TypedParameterSyntax> {
  public override class var kind: SyntaxKind {
    return .typedParameterList
  }
}

public class AscriptionSyntax: Syntax {
  public enum Cursor: Int {
    case boundNames
    case colonToken
    case typeExpr
  }

  public convenience init(boundNames: IdentifierListSyntax, colonToken: TokenSyntax, typeExpr: ExprSyntax) {
    let raw = RawSyntax.node(.ascription, [
      boundNames.raw,
      colonToken.raw,
      typeExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var boundNames: IdentifierListSyntax {
    return child(at: Cursor.boundNames) as! IdentifierListSyntax
  }
  public func withBoundNames(_ syntax: IdentifierListSyntax) -> AscriptionSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.boundNames)
  }

  public var colonToken: TokenSyntax {
    return child(at: Cursor.colonToken) as! TokenSyntax
  }
  public func withColonToken(_ syntax: TokenSyntax) -> AscriptionSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.colonToken)
  }

  public var typeExpr: ExprSyntax {
    return child(at: Cursor.typeExpr) as! ExprSyntax
  }
  public func withTypeExpr(_ syntax: ExprSyntax) -> AscriptionSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.typeExpr)
  }

}

public class TypedParameterSyntax: Syntax {
  public enum Cursor: Int {
    case leftParenToken
    case ascription
    case rightParenToken
  }

  public convenience init(leftParenToken: TokenSyntax, ascription: AscriptionSyntax, rightParenToken: TokenSyntax) {
    let raw = RawSyntax.node(.typedParameter, [
      leftParenToken.raw,
      ascription.raw,
      rightParenToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var leftParenToken: TokenSyntax {
    return child(at: Cursor.leftParenToken) as! TokenSyntax
  }
  public func withLeftParenToken(_ syntax: TokenSyntax) -> TypedParameterSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.leftParenToken)
  }

  public var ascription: AscriptionSyntax {
    return child(at: Cursor.ascription) as! AscriptionSyntax
  }
  public func withAscription(_ syntax: AscriptionSyntax) -> TypedParameterSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.ascription)
  }

  public var rightParenToken: TokenSyntax {
    return child(at: Cursor.rightParenToken) as! TokenSyntax
  }
  public func withRightParenToken(_ syntax: TokenSyntax) -> TypedParameterSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.rightParenToken)
  }

}

public class ConstructorListSyntax: SyntaxCollection<ConstructorDeclSyntax> {
  public override class var kind: SyntaxKind {
    return .constructorList
  }
}

public class ConstructorDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case pipeToken
    case ascription
  }

  public convenience init(pipeToken: TokenSyntax, ascription: AscriptionSyntax) {
    let raw = RawSyntax.node(.constructorDecl, [
      pipeToken.raw,
      ascription.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var pipeToken: TokenSyntax {
    return child(at: Cursor.pipeToken) as! TokenSyntax
  }
  public func withPipeToken(_ syntax: TokenSyntax) -> ConstructorDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.pipeToken)
  }

  public var ascription: AscriptionSyntax {
    return child(at: Cursor.ascription) as! AscriptionSyntax
  }
  public func withAscription(_ syntax: AscriptionSyntax) -> ConstructorDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.ascription)
  }

}

public class RecordDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case recordToken
    case recordName
    case parameterList
    case typeIndices
    case whereToken
    case recordElementList
  }

  public convenience init(recordToken: TokenSyntax, recordName: TokenSyntax, parameterList: TypedParameterListSyntax?, typeIndices: TypeIndicesSyntax?, whereToken: TokenSyntax?, recordElementList: RecordElementListSyntax) {
    let raw = RawSyntax.node(.recordDecl, [
      recordToken.raw,
      recordName.raw,
      parameterList?.raw ?? RawSyntax.missing(.typedParameterList),
      typeIndices?.raw ?? RawSyntax.missing(.typeIndices),
      whereToken?.raw ?? RawSyntax.missingToken(.whereKeyword),
      recordElementList.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var recordToken: TokenSyntax {
    return child(at: Cursor.recordToken) as! TokenSyntax
  }
  public func withRecordToken(_ syntax: TokenSyntax) -> RecordDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.recordToken)
  }

  public var recordName: TokenSyntax {
    return child(at: Cursor.recordName) as! TokenSyntax
  }
  public func withRecordName(_ syntax: TokenSyntax) -> RecordDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.recordName)
  }

  public var parameterList: TypedParameterListSyntax? {
    return child(at: Cursor.parameterList) as? TypedParameterListSyntax
  }
  public func withParameterList(_ syntax: TypedParameterListSyntax) -> RecordDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.parameterList)
  }

  public var typeIndices: TypeIndicesSyntax? {
    return child(at: Cursor.typeIndices) as? TypeIndicesSyntax
  }
  public func withTypeIndices(_ syntax: TypeIndicesSyntax) -> RecordDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.typeIndices)
  }

  public var whereToken: TokenSyntax? {
    return child(at: Cursor.whereToken) as? TokenSyntax
  }
  public func withWhereToken(_ syntax: TokenSyntax) -> RecordDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.whereToken)
  }

  public var recordElementList: RecordElementListSyntax {
    return child(at: Cursor.recordElementList) as! RecordElementListSyntax
  }
  public func withRecordElementList(_ syntax: RecordElementListSyntax) -> RecordDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.recordElementList)
  }

}

public class RecordElementListSyntax: SyntaxCollection<RecordElementSyntax> {
  public override class var kind: SyntaxKind {
    return .recordElementList
  }
}

public class RecordElementSyntax: Syntax {

  public convenience init() {
    let raw = RawSyntax.node(.recordElement, [
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
}

public class FieldDeclSyntax: RecordElementSyntax {
  public enum Cursor: Int {
    case fieldToken
    case ascription
  }

  public convenience init(fieldToken: TokenSyntax, ascription: AscriptionSyntax) {
    let raw = RawSyntax.node(.fieldDecl, [
      fieldToken.raw,
      ascription.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var fieldToken: TokenSyntax {
    return child(at: Cursor.fieldToken) as! TokenSyntax
  }
  public func withFieldToken(_ syntax: TokenSyntax) -> FieldDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.fieldToken)
  }

  public var ascription: AscriptionSyntax {
    return child(at: Cursor.ascription) as! AscriptionSyntax
  }
  public func withAscription(_ syntax: AscriptionSyntax) -> FieldDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.ascription)
  }

}

public class RecordFieldAssignmentListSyntax: SyntaxCollection<RecordFieldAssignmentSyntax> {
  public override class var kind: SyntaxKind {
    return .recordFieldAssignmentList
  }
}

public class RecordFieldAssignmentSyntax: Syntax {
  public enum Cursor: Int {
    case fieldName
    case equalsToken
    case fieldInitExpr
    case trailingSemicolon
  }

  public convenience init(fieldName: TokenSyntax, equalsToken: TokenSyntax, fieldInitExpr: ExprSyntax, trailingSemicolon: TokenSyntax?) {
    let raw = RawSyntax.node(.recordFieldAssignment, [
      fieldName.raw,
      equalsToken.raw,
      fieldInitExpr.raw,
      trailingSemicolon?.raw ?? RawSyntax.missingToken(.semicolon),
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var fieldName: TokenSyntax {
    return child(at: Cursor.fieldName) as! TokenSyntax
  }
  public func withFieldName(_ syntax: TokenSyntax) -> RecordFieldAssignmentSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.fieldName)
  }

  public var equalsToken: TokenSyntax {
    return child(at: Cursor.equalsToken) as! TokenSyntax
  }
  public func withEqualsToken(_ syntax: TokenSyntax) -> RecordFieldAssignmentSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.equalsToken)
  }

  public var fieldInitExpr: ExprSyntax {
    return child(at: Cursor.fieldInitExpr) as! ExprSyntax
  }
  public func withFieldInitExpr(_ syntax: ExprSyntax) -> RecordFieldAssignmentSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.fieldInitExpr)
  }

  public var trailingSemicolon: TokenSyntax? {
    return child(at: Cursor.trailingSemicolon) as? TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> RecordFieldAssignmentSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
  }

}

public class FunctionDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case ascription
    case clauseList
  }

  public convenience init(ascription: AscriptionSyntax, clauseList: FunctionClauseListSyntax) {
    let raw = RawSyntax.node(.functionDecl, [
      ascription.raw,
      clauseList.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var ascription: AscriptionSyntax {
    return child(at: Cursor.ascription) as! AscriptionSyntax
  }
  public func withAscription(_ syntax: AscriptionSyntax) -> FunctionDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.ascription)
  }

  public var clauseList: FunctionClauseListSyntax {
    return child(at: Cursor.clauseList) as! FunctionClauseListSyntax
  }
  public func withClauseList(_ syntax: FunctionClauseListSyntax) -> FunctionDeclSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.clauseList)
  }

}

public class FunctionClauseListSyntax: SyntaxCollection<FunctionClauseSyntax> {
  public override class var kind: SyntaxKind {
    return .functionClauseList
  }
}

public class FunctionClauseSyntax: Syntax {

  public convenience init() {
    let raw = RawSyntax.node(.functionClause, [
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
}

public class NormalFunctionClauseSyntax: FunctionClauseSyntax {
  public enum Cursor: Int {
    case functionName
    case patternClauseList
    case withToken
    case withExpr
    case withPatternClause
    case equalsToken
    case rhsExpr
  }

  public convenience init(functionName: TokenSyntax, patternClauseList: PatternClauseListSyntax?, withToken: TokenSyntax, withExpr: ExprSyntax, withPatternClause: PatternClauseListSyntax?, equalsToken: TokenSyntax, rhsExpr: ExprSyntax) {
    let raw = RawSyntax.node(.normalFunctionClause, [
      functionName.raw,
      patternClauseList?.raw ?? RawSyntax.missing(.patternClauseList),
      withToken.raw,
      withExpr.raw,
      withPatternClause?.raw ?? RawSyntax.missing(.patternClauseList),
      equalsToken.raw,
      rhsExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var functionName: TokenSyntax {
    return child(at: Cursor.functionName) as! TokenSyntax
  }
  public func withFunctionName(_ syntax: TokenSyntax) -> NormalFunctionClauseSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.functionName)
  }

  public var patternClauseList: PatternClauseListSyntax? {
    return child(at: Cursor.patternClauseList) as? PatternClauseListSyntax
  }
  public func withPatternClauseList(_ syntax: PatternClauseListSyntax) -> NormalFunctionClauseSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.patternClauseList)
  }

  public var withToken: TokenSyntax {
    return child(at: Cursor.withToken) as! TokenSyntax
  }
  public func withWithToken(_ syntax: TokenSyntax) -> NormalFunctionClauseSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.withToken)
  }

  public var withExpr: ExprSyntax {
    return child(at: Cursor.withExpr) as! ExprSyntax
  }
  public func withWithExpr(_ syntax: ExprSyntax) -> NormalFunctionClauseSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.withExpr)
  }

  public var withPatternClause: PatternClauseListSyntax? {
    return child(at: Cursor.withPatternClause) as? PatternClauseListSyntax
  }
  public func withWithPatternClause(_ syntax: PatternClauseListSyntax) -> NormalFunctionClauseSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.withPatternClause)
  }

  public var equalsToken: TokenSyntax {
    return child(at: Cursor.equalsToken) as! TokenSyntax
  }
  public func withEqualsToken(_ syntax: TokenSyntax) -> NormalFunctionClauseSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.equalsToken)
  }

  public var rhsExpr: ExprSyntax {
    return child(at: Cursor.rhsExpr) as! ExprSyntax
  }
  public func withRhsExpr(_ syntax: ExprSyntax) -> NormalFunctionClauseSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.rhsExpr)
  }

}

public class WithRuleFunctionClauseSyntax: FunctionClauseSyntax {
  public enum Cursor: Int {
    case functionName
    case patternClauseList
    case equalsToken
    case rhsExpr
  }

  public convenience init(functionName: TokenSyntax, patternClauseList: PatternClauseListSyntax?, equalsToken: TokenSyntax, rhsExpr: ExprSyntax) {
    let raw = RawSyntax.node(.withRuleFunctionClause, [
      functionName.raw,
      patternClauseList?.raw ?? RawSyntax.missing(.patternClauseList),
      equalsToken.raw,
      rhsExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var functionName: TokenSyntax {
    return child(at: Cursor.functionName) as! TokenSyntax
  }
  public func withFunctionName(_ syntax: TokenSyntax) -> WithRuleFunctionClauseSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.functionName)
  }

  public var patternClauseList: PatternClauseListSyntax? {
    return child(at: Cursor.patternClauseList) as? PatternClauseListSyntax
  }
  public func withPatternClauseList(_ syntax: PatternClauseListSyntax) -> WithRuleFunctionClauseSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.patternClauseList)
  }

  public var equalsToken: TokenSyntax {
    return child(at: Cursor.equalsToken) as! TokenSyntax
  }
  public func withEqualsToken(_ syntax: TokenSyntax) -> WithRuleFunctionClauseSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.equalsToken)
  }

  public var rhsExpr: ExprSyntax {
    return child(at: Cursor.rhsExpr) as! ExprSyntax
  }
  public func withRhsExpr(_ syntax: ExprSyntax) -> WithRuleFunctionClauseSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.rhsExpr)
  }

}

public class PatternClauseListSyntax: SyntaxCollection<ExprSyntax> {
  public override class var kind: SyntaxKind {
    return .patternClauseList
  }
}

public class TypedParameterArrowExprSyntax: ExprSyntax {
  public enum Cursor: Int {
    case parameter
    case arrowToken
    case outputExpr
  }

  public convenience init(parameter: TypedParameterSyntax, arrowToken: TokenSyntax, outputExpr: ExprSyntax) {
    let raw = RawSyntax.node(.typedParameterArrowExpr, [
      parameter.raw,
      arrowToken.raw,
      outputExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var parameter: TypedParameterSyntax {
    return child(at: Cursor.parameter) as! TypedParameterSyntax
  }
  public func withParameter(_ syntax: TypedParameterSyntax) -> TypedParameterArrowExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.parameter)
  }

  public var arrowToken: TokenSyntax {
    return child(at: Cursor.arrowToken) as! TokenSyntax
  }
  public func withArrowToken(_ syntax: TokenSyntax) -> TypedParameterArrowExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.arrowToken)
  }

  public var outputExpr: ExprSyntax {
    return child(at: Cursor.outputExpr) as! ExprSyntax
  }
  public func withOutputExpr(_ syntax: ExprSyntax) -> TypedParameterArrowExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.outputExpr)
  }

}

public class BasicExprListArrowExprSyntax: ExprSyntax {
  public enum Cursor: Int {
    case exprList
    case arrowToken
    case outputExpr
  }

  public convenience init(exprList: BasicExprListSyntax, arrowToken: TokenSyntax, outputExpr: ExprSyntax) {
    let raw = RawSyntax.node(.basicExprListArrowExpr, [
      exprList.raw,
      arrowToken.raw,
      outputExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var exprList: BasicExprListSyntax {
    return child(at: Cursor.exprList) as! BasicExprListSyntax
  }
  public func withExprList(_ syntax: BasicExprListSyntax) -> BasicExprListArrowExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.exprList)
  }

  public var arrowToken: TokenSyntax {
    return child(at: Cursor.arrowToken) as! TokenSyntax
  }
  public func withArrowToken(_ syntax: TokenSyntax) -> BasicExprListArrowExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.arrowToken)
  }

  public var outputExpr: ExprSyntax {
    return child(at: Cursor.outputExpr) as! ExprSyntax
  }
  public func withOutputExpr(_ syntax: ExprSyntax) -> BasicExprListArrowExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.outputExpr)
  }

}

public class LambdaExprSyntax: ExprSyntax {
  public enum Cursor: Int {
    case slashToken
    case bindingList
    case bodyExpr
  }

  public convenience init(slashToken: TokenSyntax, bindingList: BindingListSyntax, bodyExpr: ExprSyntax) {
    let raw = RawSyntax.node(.lambdaExpr, [
      slashToken.raw,
      bindingList.raw,
      bodyExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var slashToken: TokenSyntax {
    return child(at: Cursor.slashToken) as! TokenSyntax
  }
  public func withSlashToken(_ syntax: TokenSyntax) -> LambdaExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.slashToken)
  }

  public var bindingList: BindingListSyntax {
    return child(at: Cursor.bindingList) as! BindingListSyntax
  }
  public func withBindingList(_ syntax: BindingListSyntax) -> LambdaExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.bindingList)
  }

  public var bodyExpr: ExprSyntax {
    return child(at: Cursor.bodyExpr) as! ExprSyntax
  }
  public func withBodyExpr(_ syntax: ExprSyntax) -> LambdaExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.bodyExpr)
  }

}

public class QuantifiedExprSyntax: ExprSyntax {
  public enum Cursor: Int {
    case forallToken
    case bindingList
    case arrowToken
    case outputExpr
  }

  public convenience init(forallToken: TokenSyntax, bindingList: BindingListSyntax, arrowToken: TokenSyntax, outputExpr: ExprSyntax) {
    let raw = RawSyntax.node(.quantifiedExpr, [
      forallToken.raw,
      bindingList.raw,
      arrowToken.raw,
      outputExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var forallToken: TokenSyntax {
    return child(at: Cursor.forallToken) as! TokenSyntax
  }
  public func withForallToken(_ syntax: TokenSyntax) -> QuantifiedExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.forallToken)
  }

  public var bindingList: BindingListSyntax {
    return child(at: Cursor.bindingList) as! BindingListSyntax
  }
  public func withBindingList(_ syntax: BindingListSyntax) -> QuantifiedExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.bindingList)
  }

  public var arrowToken: TokenSyntax {
    return child(at: Cursor.arrowToken) as! TokenSyntax
  }
  public func withArrowToken(_ syntax: TokenSyntax) -> QuantifiedExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.arrowToken)
  }

  public var outputExpr: ExprSyntax {
    return child(at: Cursor.outputExpr) as! ExprSyntax
  }
  public func withOutputExpr(_ syntax: ExprSyntax) -> QuantifiedExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.outputExpr)
  }

}

public class LetExprSyntax: ExprSyntax {
  public enum Cursor: Int {
    case letToken
    case declList
    case inToken
    case outputExpr
  }

  public convenience init(letToken: TokenSyntax, declList: DeclListSyntax, inToken: TokenSyntax, outputExpr: ExprSyntax) {
    let raw = RawSyntax.node(.letExpr, [
      letToken.raw,
      declList.raw,
      inToken.raw,
      outputExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var letToken: TokenSyntax {
    return child(at: Cursor.letToken) as! TokenSyntax
  }
  public func withLetToken(_ syntax: TokenSyntax) -> LetExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.letToken)
  }

  public var declList: DeclListSyntax {
    return child(at: Cursor.declList) as! DeclListSyntax
  }
  public func withDeclList(_ syntax: DeclListSyntax) -> LetExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.declList)
  }

  public var inToken: TokenSyntax {
    return child(at: Cursor.inToken) as! TokenSyntax
  }
  public func withInToken(_ syntax: TokenSyntax) -> LetExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.inToken)
  }

  public var outputExpr: ExprSyntax {
    return child(at: Cursor.outputExpr) as! ExprSyntax
  }
  public func withOutputExpr(_ syntax: ExprSyntax) -> LetExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.outputExpr)
  }

}

public class ApplicationExprSyntax: ExprSyntax {
  public enum Cursor: Int {
    case exprs
  }

  public convenience init(exprs: ApplicationExprListSyntax) {
    let raw = RawSyntax.node(.applicationExpr, [
      exprs.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var exprs: ApplicationExprListSyntax {
    return child(at: Cursor.exprs) as! ApplicationExprListSyntax
  }
  public func withExprs(_ syntax: ApplicationExprListSyntax) -> ApplicationExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.exprs)
  }

}

public class BasicExprSyntax: ExprSyntax {

  public convenience init() {
    let raw = RawSyntax.node(.basicExpr, [
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
}

public class ApplicationExprListSyntax: SyntaxCollection<BasicExprSyntax> {
  public override class var kind: SyntaxKind {
    return .applicationExprList
  }
}

public class BindingListSyntax: SyntaxCollection<BindingSyntax> {
  public override class var kind: SyntaxKind {
    return .bindingList
  }
}

public class BindingSyntax: Syntax {

  public convenience init() {
    let raw = RawSyntax.node(.binding, [
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
}

public class NamedBindingSyntax: BindingSyntax {
  public enum Cursor: Int {
    case name
  }

  public convenience init(name: QualifiedNameSyntax) {
    let raw = RawSyntax.node(.namedBinding, [
      name.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var name: QualifiedNameSyntax {
    return child(at: Cursor.name) as! QualifiedNameSyntax
  }
  public func withName(_ syntax: QualifiedNameSyntax) -> NamedBindingSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.name)
  }

}

public class TypedBindingSyntax: BindingSyntax {
  public enum Cursor: Int {
    case parameter
  }

  public convenience init(parameter: TypedParameterSyntax) {
    let raw = RawSyntax.node(.typedBinding, [
      parameter.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var parameter: TypedParameterSyntax {
    return child(at: Cursor.parameter) as! TypedParameterSyntax
  }
  public func withParameter(_ syntax: TypedParameterSyntax) -> TypedBindingSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.parameter)
  }

}

public class BasicExprListSyntax: SyntaxCollection<BasicExprSyntax> {
  public override class var kind: SyntaxKind {
    return .basicExprList
  }
}

public class NamedBasicExprSyntax: BasicExprSyntax {
  public enum Cursor: Int {
    case name
  }

  public convenience init(name: QualifiedNameSyntax) {
    let raw = RawSyntax.node(.namedBasicExpr, [
      name.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var name: QualifiedNameSyntax {
    return child(at: Cursor.name) as! QualifiedNameSyntax
  }
  public func withName(_ syntax: QualifiedNameSyntax) -> NamedBasicExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.name)
  }

}

public class UnderscoreExprSyntax: BasicExprSyntax {
  public enum Cursor: Int {
    case underscoreToken
  }

  public convenience init(underscoreToken: TokenSyntax) {
    let raw = RawSyntax.node(.underscoreExpr, [
      underscoreToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var underscoreToken: TokenSyntax {
    return child(at: Cursor.underscoreToken) as! TokenSyntax
  }
  public func withUnderscoreToken(_ syntax: TokenSyntax) -> UnderscoreExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.underscoreToken)
  }

}

public class TypeBasicExprSyntax: BasicExprSyntax {
  public enum Cursor: Int {
    case typeToken
  }

  public convenience init(typeToken: TokenSyntax) {
    let raw = RawSyntax.node(.typeBasicExpr, [
      typeToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var typeToken: TokenSyntax {
    return child(at: Cursor.typeToken) as! TokenSyntax
  }
  public func withTypeToken(_ syntax: TokenSyntax) -> TypeBasicExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.typeToken)
  }

}

public class ParenthesizedExprSyntax: BasicExprSyntax {
  public enum Cursor: Int {
    case leftParenToken
    case expr
    case rightParenToken
  }

  public convenience init(leftParenToken: TokenSyntax, expr: ExprSyntax, rightParenToken: TokenSyntax) {
    let raw = RawSyntax.node(.parenthesizedExpr, [
      leftParenToken.raw,
      expr.raw,
      rightParenToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var leftParenToken: TokenSyntax {
    return child(at: Cursor.leftParenToken) as! TokenSyntax
  }
  public func withLeftParenToken(_ syntax: TokenSyntax) -> ParenthesizedExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.leftParenToken)
  }

  public var expr: ExprSyntax {
    return child(at: Cursor.expr) as! ExprSyntax
  }
  public func withExpr(_ syntax: ExprSyntax) -> ParenthesizedExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.expr)
  }

  public var rightParenToken: TokenSyntax {
    return child(at: Cursor.rightParenToken) as! TokenSyntax
  }
  public func withRightParenToken(_ syntax: TokenSyntax) -> ParenthesizedExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.rightParenToken)
  }

}

public class RecordExprSyntax: BasicExprSyntax {
  public enum Cursor: Int {
    case recordToken
    case parameterExpr
    case leftBraceToken
    case fieldAssignments
    case rightBraceToken
  }

  public convenience init(recordToken: TokenSyntax, parameterExpr: BasicExprSyntax, leftBraceToken: TokenSyntax, fieldAssignments: RecordFieldAssignmentListSyntax?, rightBraceToken: TokenSyntax) {
    let raw = RawSyntax.node(.recordExpr, [
      recordToken.raw,
      parameterExpr.raw,
      leftBraceToken.raw,
      fieldAssignments?.raw ?? RawSyntax.missing(.recordFieldAssignmentList),
      rightBraceToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var recordToken: TokenSyntax {
    return child(at: Cursor.recordToken) as! TokenSyntax
  }
  public func withRecordToken(_ syntax: TokenSyntax) -> RecordExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.recordToken)
  }

  public var parameterExpr: BasicExprSyntax {
    return child(at: Cursor.parameterExpr) as! BasicExprSyntax
  }
  public func withParameterExpr(_ syntax: BasicExprSyntax) -> RecordExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.parameterExpr)
  }

  public var leftBraceToken: TokenSyntax {
    return child(at: Cursor.leftBraceToken) as! TokenSyntax
  }
  public func withLeftBraceToken(_ syntax: TokenSyntax) -> RecordExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.leftBraceToken)
  }

  public var fieldAssignments: RecordFieldAssignmentListSyntax? {
    return child(at: Cursor.fieldAssignments) as? RecordFieldAssignmentListSyntax
  }
  public func withFieldAssignments(_ syntax: RecordFieldAssignmentListSyntax) -> RecordExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.fieldAssignments)
  }

  public var rightBraceToken: TokenSyntax {
    return child(at: Cursor.rightBraceToken) as! TokenSyntax
  }
  public func withRightBraceToken(_ syntax: TokenSyntax) -> RecordExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.rightBraceToken)
  }

}

