/// TokenKind.swift
/// Automatically generated by SyntaxGen. Do not edit!
///
/// Copyright 2017, The Silt Language Project.
///
/// This project is released under the MIT license, a copy of which is
/// available in the repository.
public enum TokenKind: Equatable {
  case eof
  case infixlKeyword
  case infixKeyword
  case forallSymbol
  case moduleKeyword
  case arrow
  case pipe
  case underscore
  case semicolon
  case letKeyword
  case forwardSlash
  case importKeyword
  case recordKeyword
  case fieldKeyword
  case rightParen
  case colon
  case openKeyword
  case constructorKeyword
  case unknown(Character)
  case equals
  case arrowSymbol
  case dataKeyword
  case forallKeyword
  case leftBrace
  case typeKeyword
  case withKeyword
  case infixrKeyword
  case identifier(String)
  case rightBrace
  case leftParen
  case inKeyword
  case whereKeyword
  case period

  public init(text: String) {
    switch text {
    case "infixl": self = .infixlKeyword
    case "infix": self = .infixKeyword
    case "∀": self = .forallSymbol
    case "module": self = .moduleKeyword
    case "->": self = .arrow
    case "|": self = .pipe
    case "_": self = .underscore
    case ";": self = .semicolon
    case "let": self = .letKeyword
    case "\\": self = .forwardSlash
    case "import": self = .importKeyword
    case "record": self = .recordKeyword
    case "field": self = .fieldKeyword
    case ")": self = .rightParen
    case ":": self = .colon
    case "open": self = .openKeyword
    case "constructor": self = .constructorKeyword
    case "=": self = .equals
    case "→": self = .arrowSymbol
    case "data": self = .dataKeyword
    case "forall": self = .forallKeyword
    case "{": self = .leftBrace
    case "Type": self = .typeKeyword
    case "with": self = .withKeyword
    case "infixr": self = .infixrKeyword
    case "}": self = .rightBrace
    case "(": self = .leftParen
    case "in": self = .inKeyword
    case "where": self = .whereKeyword
    case ".": self = .period
    default: self = .identifier(text)
    }
  }
  public var text: String {
    switch self {
    case .eof: return ""
    case .infixlKeyword: return "infixl"
    case .infixKeyword: return "infix"
    case .forallSymbol: return "∀"
    case .moduleKeyword: return "module"
    case .arrow: return "->"
    case .pipe: return "|"
    case .underscore: return "_"
    case .semicolon: return ";"
    case .letKeyword: return "let"
    case .forwardSlash: return "\\"
    case .importKeyword: return "import"
    case .recordKeyword: return "record"
    case .fieldKeyword: return "field"
    case .rightParen: return ")"
    case .colon: return ":"
    case .openKeyword: return "open"
    case .constructorKeyword: return "constructor"
    case .unknown(let text): return text.description
    case .equals: return "="
    case .arrowSymbol: return "→"
    case .dataKeyword: return "data"
    case .forallKeyword: return "forall"
    case .leftBrace: return "{"
    case .typeKeyword: return "Type"
    case .withKeyword: return "with"
    case .infixrKeyword: return "infixr"
    case .identifier(let text): return text.description
    case .rightBrace: return "}"
    case .leftParen: return "("
    case .inKeyword: return "in"
    case .whereKeyword: return "where"
    case .period: return "."
    }
  }
  public static func == (lhs: TokenKind, rhs: TokenKind) -> Bool {
    switch (lhs, rhs) {
    case (.eof, .eof): return true
    case (.infixlKeyword, .infixlKeyword): return true
    case (.infixKeyword, .infixKeyword): return true
    case (.forallSymbol, .forallSymbol): return true
    case (.moduleKeyword, .moduleKeyword): return true
    case (.arrow, .arrow): return true
    case (.pipe, .pipe): return true
    case (.underscore, .underscore): return true
    case (.semicolon, .semicolon): return true
    case (.letKeyword, .letKeyword): return true
    case (.forwardSlash, .forwardSlash): return true
    case (.importKeyword, .importKeyword): return true
    case (.recordKeyword, .recordKeyword): return true
    case (.fieldKeyword, .fieldKeyword): return true
    case (.rightParen, .rightParen): return true
    case (.colon, .colon): return true
    case (.openKeyword, .openKeyword): return true
    case (.constructorKeyword, .constructorKeyword): return true
    case (.unknown(let l),
          .unknown(let r)): return l == r
    case (.equals, .equals): return true
    case (.arrowSymbol, .arrowSymbol): return true
    case (.dataKeyword, .dataKeyword): return true
    case (.forallKeyword, .forallKeyword): return true
    case (.leftBrace, .leftBrace): return true
    case (.typeKeyword, .typeKeyword): return true
    case (.withKeyword, .withKeyword): return true
    case (.infixrKeyword, .infixrKeyword): return true
    case (.identifier(let l),
          .identifier(let r)): return l == r
    case (.rightBrace, .rightBrace): return true
    case (.leftParen, .leftParen): return true
    case (.inKeyword, .inKeyword): return true
    case (.whereKeyword, .whereKeyword): return true
    case (.period, .period): return true
    default: return false
    }
  }
}
