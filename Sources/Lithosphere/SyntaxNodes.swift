/// SyntaxNodes.swift
/// Automatically generated by SyntaxGen. Do not edit!
///
/// Copyright 2017, The Silt Language Project.
///
/// This project is released under the MIT license, a copy of which is
/// available in the repository.
public class ExprSyntax: Syntax {}
public class DeclSyntax: Syntax {}
public final class IdentifierListSyntax: SyntaxCollection<TokenSyntax> {
  internal override init(root: SyntaxData, data: SyntaxData) {
    super.init(root: root, data: data)
  }
  public init(elements: [TokenSyntax]) {
    super.init(kind: .identifierList, elements: elements)
  }
}

public final class QualifiedNameSyntax: SyntaxCollection<QualifiedNamePieceSyntax> {
  internal override init(root: SyntaxData, data: SyntaxData) {
    super.init(root: root, data: data)
  }
  public init(elements: [QualifiedNamePieceSyntax]) {
    super.init(kind: .qualifiedName, elements: elements)
  }
}

public class QualifiedNamePieceSyntax: Syntax {
  public enum Cursor: Int {
    case name
    case trailingPeriod
  }

  public convenience init(name: TokenSyntax, trailingPeriod: TokenSyntax?) {
    let raw = RawSyntax.node(.qualifiedNamePiece, [
      name.raw,
      trailingPeriod?.raw ?? RawSyntax.missingToken(.period),
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var name: TokenSyntax {
    return child(at: Cursor.name) as! TokenSyntax
  }
  public func withName(_ syntax: TokenSyntax) -> QualifiedNamePieceSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.name)
    return QualifiedNamePieceSyntax(root: newRoot, data: newData)
  }

  public var trailingPeriod: TokenSyntax? {
    return child(at: Cursor.trailingPeriod) as? TokenSyntax
  }
  public func withTrailingPeriod(_ syntax: TokenSyntax) -> QualifiedNamePieceSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingPeriod)
    return QualifiedNamePieceSyntax(root: newRoot, data: newData)
  }

}

public class ModuleDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case moduleToken
    case moduleIdentifier
    case typedParameterList
    case whereToken
    case leftBraceToken
    case declList
    case rightBraceToken
    case trailingSemicolon
  }

  public convenience init(moduleToken: TokenSyntax, moduleIdentifier: QualifiedNameSyntax, typedParameterList: TypedParameterListSyntax?, whereToken: TokenSyntax, leftBraceToken: TokenSyntax, declList: DeclListSyntax, rightBraceToken: TokenSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.moduleDecl, [
      moduleToken.raw,
      moduleIdentifier.raw,
      typedParameterList?.raw ?? RawSyntax.missing(.typedParameterList),
      whereToken.raw,
      leftBraceToken.raw,
      declList.raw,
      rightBraceToken.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var moduleToken: TokenSyntax {
    return child(at: Cursor.moduleToken) as! TokenSyntax
  }
  public func withModuleToken(_ syntax: TokenSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.moduleToken)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

  public var moduleIdentifier: QualifiedNameSyntax {
    return child(at: Cursor.moduleIdentifier) as! QualifiedNameSyntax
  }
  public func withModuleIdentifier(_ syntax: QualifiedNameSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.moduleIdentifier)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

  public var typedParameterList: TypedParameterListSyntax? {
    return child(at: Cursor.typedParameterList) as? TypedParameterListSyntax
  }
  public func withTypedParameterList(_ syntax: TypedParameterListSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.typedParameterList)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

  public var whereToken: TokenSyntax {
    return child(at: Cursor.whereToken) as! TokenSyntax
  }
  public func withWhereToken(_ syntax: TokenSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.whereToken)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

  public var leftBraceToken: TokenSyntax {
    return child(at: Cursor.leftBraceToken) as! TokenSyntax
  }
  public func withLeftBraceToken(_ syntax: TokenSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.leftBraceToken)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

  public var declList: DeclListSyntax {
    return child(at: Cursor.declList) as! DeclListSyntax
  }
  public func withDeclList(_ syntax: DeclListSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.declList)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

  public var rightBraceToken: TokenSyntax {
    return child(at: Cursor.rightBraceToken) as! TokenSyntax
  }
  public func withRightBraceToken(_ syntax: TokenSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rightBraceToken)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

}

public final class DeclListSyntax: SyntaxCollection<DeclSyntax> {
  internal override init(root: SyntaxData, data: SyntaxData) {
    super.init(root: root, data: data)
  }
  public init(elements: [DeclSyntax]) {
    super.init(kind: .declList, elements: elements)
  }
}

public class OpenImportDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case openToken
    case importToken
    case importIdentifier
  }

  public convenience init(openToken: TokenSyntax?, importToken: TokenSyntax, importIdentifier: QualifiedNameSyntax) {
    let raw = RawSyntax.node(.openImportDecl, [
      openToken?.raw ?? RawSyntax.missingToken(.openKeyword),
      importToken.raw,
      importIdentifier.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var openToken: TokenSyntax? {
    return child(at: Cursor.openToken) as? TokenSyntax
  }
  public func withOpenToken(_ syntax: TokenSyntax) -> OpenImportDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.openToken)
    return OpenImportDeclSyntax(root: newRoot, data: newData)
  }

  public var importToken: TokenSyntax {
    return child(at: Cursor.importToken) as! TokenSyntax
  }
  public func withImportToken(_ syntax: TokenSyntax) -> OpenImportDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.importToken)
    return OpenImportDeclSyntax(root: newRoot, data: newData)
  }

  public var importIdentifier: QualifiedNameSyntax {
    return child(at: Cursor.importIdentifier) as! QualifiedNameSyntax
  }
  public func withImportIdentifier(_ syntax: QualifiedNameSyntax) -> OpenImportDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.importIdentifier)
    return OpenImportDeclSyntax(root: newRoot, data: newData)
  }

}

public class ImportDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case importToken
    case importIdentifier
  }

  public convenience init(importToken: TokenSyntax, importIdentifier: QualifiedNameSyntax) {
    let raw = RawSyntax.node(.importDecl, [
      importToken.raw,
      importIdentifier.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var importToken: TokenSyntax {
    return child(at: Cursor.importToken) as! TokenSyntax
  }
  public func withImportToken(_ syntax: TokenSyntax) -> ImportDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.importToken)
    return ImportDeclSyntax(root: newRoot, data: newData)
  }

  public var importIdentifier: QualifiedNameSyntax {
    return child(at: Cursor.importIdentifier) as! QualifiedNameSyntax
  }
  public func withImportIdentifier(_ syntax: QualifiedNameSyntax) -> ImportDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.importIdentifier)
    return ImportDeclSyntax(root: newRoot, data: newData)
  }

}

public class DataDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case dataToken
    case dataIdentifier
    case typedParameterList
    case typeIndices
    case whereToken
    case leftBraceToken
    case constructorList
    case rightBraceToken
    case trailingSemicolon
  }

  public convenience init(dataToken: TokenSyntax, dataIdentifier: TokenSyntax, typedParameterList: TypedParameterListSyntax?, typeIndices: TypeIndicesSyntax, whereToken: TokenSyntax, leftBraceToken: TokenSyntax, constructorList: ConstructorListSyntax, rightBraceToken: TokenSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.dataDecl, [
      dataToken.raw,
      dataIdentifier.raw,
      typedParameterList?.raw ?? RawSyntax.missing(.typedParameterList),
      typeIndices.raw,
      whereToken.raw,
      leftBraceToken.raw,
      constructorList.raw,
      rightBraceToken.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var dataToken: TokenSyntax {
    return child(at: Cursor.dataToken) as! TokenSyntax
  }
  public func withDataToken(_ syntax: TokenSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.dataToken)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var dataIdentifier: TokenSyntax {
    return child(at: Cursor.dataIdentifier) as! TokenSyntax
  }
  public func withDataIdentifier(_ syntax: TokenSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.dataIdentifier)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var typedParameterList: TypedParameterListSyntax? {
    return child(at: Cursor.typedParameterList) as? TypedParameterListSyntax
  }
  public func withTypedParameterList(_ syntax: TypedParameterListSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.typedParameterList)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var typeIndices: TypeIndicesSyntax {
    return child(at: Cursor.typeIndices) as! TypeIndicesSyntax
  }
  public func withTypeIndices(_ syntax: TypeIndicesSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.typeIndices)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var whereToken: TokenSyntax {
    return child(at: Cursor.whereToken) as! TokenSyntax
  }
  public func withWhereToken(_ syntax: TokenSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.whereToken)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var leftBraceToken: TokenSyntax {
    return child(at: Cursor.leftBraceToken) as! TokenSyntax
  }
  public func withLeftBraceToken(_ syntax: TokenSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.leftBraceToken)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var constructorList: ConstructorListSyntax {
    return child(at: Cursor.constructorList) as! ConstructorListSyntax
  }
  public func withConstructorList(_ syntax: ConstructorListSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.constructorList)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var rightBraceToken: TokenSyntax {
    return child(at: Cursor.rightBraceToken) as! TokenSyntax
  }
  public func withRightBraceToken(_ syntax: TokenSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rightBraceToken)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

}

public class TypeIndicesSyntax: Syntax {
  public enum Cursor: Int {
    case colonToken
    case indexExpr
  }

  public convenience init(colonToken: TokenSyntax, indexExpr: ExprSyntax) {
    let raw = RawSyntax.node(.typeIndices, [
      colonToken.raw,
      indexExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var colonToken: TokenSyntax {
    return child(at: Cursor.colonToken) as! TokenSyntax
  }
  public func withColonToken(_ syntax: TokenSyntax) -> TypeIndicesSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.colonToken)
    return TypeIndicesSyntax(root: newRoot, data: newData)
  }

  public var indexExpr: ExprSyntax {
    return child(at: Cursor.indexExpr) as! ExprSyntax
  }
  public func withIndexExpr(_ syntax: ExprSyntax) -> TypeIndicesSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.indexExpr)
    return TypeIndicesSyntax(root: newRoot, data: newData)
  }

}

public final class TypedParameterListSyntax: SyntaxCollection<TypedParameterSyntax> {
  internal override init(root: SyntaxData, data: SyntaxData) {
    super.init(root: root, data: data)
  }
  public init(elements: [TypedParameterSyntax]) {
    super.init(kind: .typedParameterList, elements: elements)
  }
}

public class AscriptionSyntax: Syntax {
  public enum Cursor: Int {
    case boundNames
    case colonToken
    case typeExpr
  }

  public convenience init(boundNames: IdentifierListSyntax, colonToken: TokenSyntax, typeExpr: ExprSyntax) {
    let raw = RawSyntax.node(.ascription, [
      boundNames.raw,
      colonToken.raw,
      typeExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var boundNames: IdentifierListSyntax {
    return child(at: Cursor.boundNames) as! IdentifierListSyntax
  }
  public func withBoundNames(_ syntax: IdentifierListSyntax) -> AscriptionSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.boundNames)
    return AscriptionSyntax(root: newRoot, data: newData)
  }

  public var colonToken: TokenSyntax {
    return child(at: Cursor.colonToken) as! TokenSyntax
  }
  public func withColonToken(_ syntax: TokenSyntax) -> AscriptionSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.colonToken)
    return AscriptionSyntax(root: newRoot, data: newData)
  }

  public var typeExpr: ExprSyntax {
    return child(at: Cursor.typeExpr) as! ExprSyntax
  }
  public func withTypeExpr(_ syntax: ExprSyntax) -> AscriptionSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.typeExpr)
    return AscriptionSyntax(root: newRoot, data: newData)
  }

}

public class TypedParameterSyntax: Syntax {

  public convenience init() {
    let raw = RawSyntax.node(.typedParameter, [
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
}

public class ExplicitTypedParameterSyntax: TypedParameterSyntax {
  public enum Cursor: Int {
    case leftParenToken
    case ascription
    case rightParenToken
  }

  public convenience init(leftParenToken: TokenSyntax, ascription: AscriptionSyntax, rightParenToken: TokenSyntax) {
    let raw = RawSyntax.node(.explicitTypedParameter, [
      leftParenToken.raw,
      ascription.raw,
      rightParenToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var leftParenToken: TokenSyntax {
    return child(at: Cursor.leftParenToken) as! TokenSyntax
  }
  public func withLeftParenToken(_ syntax: TokenSyntax) -> ExplicitTypedParameterSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.leftParenToken)
    return ExplicitTypedParameterSyntax(root: newRoot, data: newData)
  }

  public var ascription: AscriptionSyntax {
    return child(at: Cursor.ascription) as! AscriptionSyntax
  }
  public func withAscription(_ syntax: AscriptionSyntax) -> ExplicitTypedParameterSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.ascription)
    return ExplicitTypedParameterSyntax(root: newRoot, data: newData)
  }

  public var rightParenToken: TokenSyntax {
    return child(at: Cursor.rightParenToken) as! TokenSyntax
  }
  public func withRightParenToken(_ syntax: TokenSyntax) -> ExplicitTypedParameterSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rightParenToken)
    return ExplicitTypedParameterSyntax(root: newRoot, data: newData)
  }

}

public class ImplicitTypedParameterSyntax: TypedParameterSyntax {
  public enum Cursor: Int {
    case leftBraceToken
    case ascription
    case rightBraceToken
  }

  public convenience init(leftBraceToken: TokenSyntax, ascription: AscriptionSyntax, rightBraceToken: TokenSyntax) {
    let raw = RawSyntax.node(.implicitTypedParameter, [
      leftBraceToken.raw,
      ascription.raw,
      rightBraceToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var leftBraceToken: TokenSyntax {
    return child(at: Cursor.leftBraceToken) as! TokenSyntax
  }
  public func withLeftBraceToken(_ syntax: TokenSyntax) -> ImplicitTypedParameterSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.leftBraceToken)
    return ImplicitTypedParameterSyntax(root: newRoot, data: newData)
  }

  public var ascription: AscriptionSyntax {
    return child(at: Cursor.ascription) as! AscriptionSyntax
  }
  public func withAscription(_ syntax: AscriptionSyntax) -> ImplicitTypedParameterSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.ascription)
    return ImplicitTypedParameterSyntax(root: newRoot, data: newData)
  }

  public var rightBraceToken: TokenSyntax {
    return child(at: Cursor.rightBraceToken) as! TokenSyntax
  }
  public func withRightBraceToken(_ syntax: TokenSyntax) -> ImplicitTypedParameterSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rightBraceToken)
    return ImplicitTypedParameterSyntax(root: newRoot, data: newData)
  }

}

public final class ConstructorListSyntax: SyntaxCollection<ConstructorDeclSyntax> {
  internal override init(root: SyntaxData, data: SyntaxData) {
    super.init(root: root, data: data)
  }
  public init(elements: [ConstructorDeclSyntax]) {
    super.init(kind: .constructorList, elements: elements)
  }
}

public class ConstructorDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case pipeToken
    case ascription
    case trailingSemicolon
  }

  public convenience init(pipeToken: TokenSyntax, ascription: AscriptionSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.constructorDecl, [
      pipeToken.raw,
      ascription.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var pipeToken: TokenSyntax {
    return child(at: Cursor.pipeToken) as! TokenSyntax
  }
  public func withPipeToken(_ syntax: TokenSyntax) -> ConstructorDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.pipeToken)
    return ConstructorDeclSyntax(root: newRoot, data: newData)
  }

  public var ascription: AscriptionSyntax {
    return child(at: Cursor.ascription) as! AscriptionSyntax
  }
  public func withAscription(_ syntax: AscriptionSyntax) -> ConstructorDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.ascription)
    return ConstructorDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> ConstructorDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return ConstructorDeclSyntax(root: newRoot, data: newData)
  }

}

public class RecordDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case recordToken
    case recordName
    case parameterList
    case typeIndices
    case whereToken
    case recordElementList
  }

  public convenience init(recordToken: TokenSyntax, recordName: TokenSyntax, parameterList: TypedParameterListSyntax, typeIndices: TypeIndicesSyntax?, whereToken: TokenSyntax, recordElementList: RecordElementListSyntax) {
    let raw = RawSyntax.node(.recordDecl, [
      recordToken.raw,
      recordName.raw,
      parameterList.raw,
      typeIndices?.raw ?? RawSyntax.missing(.typeIndices),
      whereToken.raw,
      recordElementList.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var recordToken: TokenSyntax {
    return child(at: Cursor.recordToken) as! TokenSyntax
  }
  public func withRecordToken(_ syntax: TokenSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.recordToken)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

  public var recordName: TokenSyntax {
    return child(at: Cursor.recordName) as! TokenSyntax
  }
  public func withRecordName(_ syntax: TokenSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.recordName)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

  public var parameterList: TypedParameterListSyntax {
    return child(at: Cursor.parameterList) as! TypedParameterListSyntax
  }
  public func withParameterList(_ syntax: TypedParameterListSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.parameterList)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

  public var typeIndices: TypeIndicesSyntax? {
    return child(at: Cursor.typeIndices) as? TypeIndicesSyntax
  }
  public func withTypeIndices(_ syntax: TypeIndicesSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.typeIndices)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

  public var whereToken: TokenSyntax {
    return child(at: Cursor.whereToken) as! TokenSyntax
  }
  public func withWhereToken(_ syntax: TokenSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.whereToken)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

  public var recordElementList: RecordElementListSyntax {
    return child(at: Cursor.recordElementList) as! RecordElementListSyntax
  }
  public func withRecordElementList(_ syntax: RecordElementListSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.recordElementList)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

}

public final class RecordElementListSyntax: SyntaxCollection<DeclSyntax> {
  internal override init(root: SyntaxData, data: SyntaxData) {
    super.init(root: root, data: data)
  }
  public init(elements: [DeclSyntax]) {
    super.init(kind: .recordElementList, elements: elements)
  }
}

public class FieldDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case fieldToken
    case leftBraceToken
    case ascription
    case rightBraceToken
  }

  public convenience init(fieldToken: TokenSyntax, leftBraceToken: TokenSyntax, ascription: AscriptionSyntax, rightBraceToken: TokenSyntax) {
    let raw = RawSyntax.node(.fieldDecl, [
      fieldToken.raw,
      leftBraceToken.raw,
      ascription.raw,
      rightBraceToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var fieldToken: TokenSyntax {
    return child(at: Cursor.fieldToken) as! TokenSyntax
  }
  public func withFieldToken(_ syntax: TokenSyntax) -> FieldDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.fieldToken)
    return FieldDeclSyntax(root: newRoot, data: newData)
  }

  public var leftBraceToken: TokenSyntax {
    return child(at: Cursor.leftBraceToken) as! TokenSyntax
  }
  public func withLeftBraceToken(_ syntax: TokenSyntax) -> FieldDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.leftBraceToken)
    return FieldDeclSyntax(root: newRoot, data: newData)
  }

  public var ascription: AscriptionSyntax {
    return child(at: Cursor.ascription) as! AscriptionSyntax
  }
  public func withAscription(_ syntax: AscriptionSyntax) -> FieldDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.ascription)
    return FieldDeclSyntax(root: newRoot, data: newData)
  }

  public var rightBraceToken: TokenSyntax {
    return child(at: Cursor.rightBraceToken) as! TokenSyntax
  }
  public func withRightBraceToken(_ syntax: TokenSyntax) -> FieldDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rightBraceToken)
    return FieldDeclSyntax(root: newRoot, data: newData)
  }

}

public final class RecordFieldAssignmentListSyntax: SyntaxCollection<RecordFieldAssignmentSyntax> {
  internal override init(root: SyntaxData, data: SyntaxData) {
    super.init(root: root, data: data)
  }
  public init(elements: [RecordFieldAssignmentSyntax]) {
    super.init(kind: .recordFieldAssignmentList, elements: elements)
  }
}

public class RecordFieldAssignmentSyntax: Syntax {
  public enum Cursor: Int {
    case fieldName
    case equalsToken
    case fieldInitExpr
    case trailingSemicolon
  }

  public convenience init(fieldName: TokenSyntax, equalsToken: TokenSyntax, fieldInitExpr: ExprSyntax, trailingSemicolon: TokenSyntax?) {
    let raw = RawSyntax.node(.recordFieldAssignment, [
      fieldName.raw,
      equalsToken.raw,
      fieldInitExpr.raw,
      trailingSemicolon?.raw ?? RawSyntax.missingToken(.semicolon),
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var fieldName: TokenSyntax {
    return child(at: Cursor.fieldName) as! TokenSyntax
  }
  public func withFieldName(_ syntax: TokenSyntax) -> RecordFieldAssignmentSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.fieldName)
    return RecordFieldAssignmentSyntax(root: newRoot, data: newData)
  }

  public var equalsToken: TokenSyntax {
    return child(at: Cursor.equalsToken) as! TokenSyntax
  }
  public func withEqualsToken(_ syntax: TokenSyntax) -> RecordFieldAssignmentSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.equalsToken)
    return RecordFieldAssignmentSyntax(root: newRoot, data: newData)
  }

  public var fieldInitExpr: ExprSyntax {
    return child(at: Cursor.fieldInitExpr) as! ExprSyntax
  }
  public func withFieldInitExpr(_ syntax: ExprSyntax) -> RecordFieldAssignmentSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.fieldInitExpr)
    return RecordFieldAssignmentSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax? {
    return child(at: Cursor.trailingSemicolon) as? TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> RecordFieldAssignmentSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return RecordFieldAssignmentSyntax(root: newRoot, data: newData)
  }

}

public class FunctionDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case ascription
    case trailingSemicolon
  }

  public convenience init(ascription: AscriptionSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.functionDecl, [
      ascription.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var ascription: AscriptionSyntax {
    return child(at: Cursor.ascription) as! AscriptionSyntax
  }
  public func withAscription(_ syntax: AscriptionSyntax) -> FunctionDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.ascription)
    return FunctionDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> FunctionDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return FunctionDeclSyntax(root: newRoot, data: newData)
  }

}

public class FunctionClauseDeclSyntax: DeclSyntax {

  public convenience init() {
    let raw = RawSyntax.node(.functionClauseDecl, [
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
}

public class WithRuleFunctionClauseDeclSyntax: FunctionClauseDeclSyntax {
  public enum Cursor: Int {
    case basicExprList
    case withToken
    case withExpr
    case withPatternClause
    case equalsToken
    case rhsExpr
    case trailingSemicolon
  }

  public convenience init(basicExprList: BasicExprListSyntax, withToken: TokenSyntax, withExpr: ExprSyntax, withPatternClause: BasicExprListSyntax?, equalsToken: TokenSyntax, rhsExpr: ExprSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.withRuleFunctionClauseDecl, [
      basicExprList.raw,
      withToken.raw,
      withExpr.raw,
      withPatternClause?.raw ?? RawSyntax.missing(.basicExprList),
      equalsToken.raw,
      rhsExpr.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var basicExprList: BasicExprListSyntax {
    return child(at: Cursor.basicExprList) as! BasicExprListSyntax
  }
  public func withBasicExprList(_ syntax: BasicExprListSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.basicExprList)
    return WithRuleFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var withToken: TokenSyntax {
    return child(at: Cursor.withToken) as! TokenSyntax
  }
  public func withWithToken(_ syntax: TokenSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.withToken)
    return WithRuleFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var withExpr: ExprSyntax {
    return child(at: Cursor.withExpr) as! ExprSyntax
  }
  public func withWithExpr(_ syntax: ExprSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.withExpr)
    return WithRuleFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var withPatternClause: BasicExprListSyntax? {
    return child(at: Cursor.withPatternClause) as? BasicExprListSyntax
  }
  public func withWithPatternClause(_ syntax: BasicExprListSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.withPatternClause)
    return WithRuleFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var equalsToken: TokenSyntax {
    return child(at: Cursor.equalsToken) as! TokenSyntax
  }
  public func withEqualsToken(_ syntax: TokenSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.equalsToken)
    return WithRuleFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var rhsExpr: ExprSyntax {
    return child(at: Cursor.rhsExpr) as! ExprSyntax
  }
  public func withRhsExpr(_ syntax: ExprSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rhsExpr)
    return WithRuleFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return WithRuleFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

}

public class NormalFunctionClauseDeclSyntax: FunctionClauseDeclSyntax {
  public enum Cursor: Int {
    case basicExprList
    case equalsToken
    case rhsExpr
    case trailingSemicolon
  }

  public convenience init(basicExprList: BasicExprListSyntax, equalsToken: TokenSyntax, rhsExpr: ExprSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.normalFunctionClauseDecl, [
      basicExprList.raw,
      equalsToken.raw,
      rhsExpr.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var basicExprList: BasicExprListSyntax {
    return child(at: Cursor.basicExprList) as! BasicExprListSyntax
  }
  public func withBasicExprList(_ syntax: BasicExprListSyntax) -> NormalFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.basicExprList)
    return NormalFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var equalsToken: TokenSyntax {
    return child(at: Cursor.equalsToken) as! TokenSyntax
  }
  public func withEqualsToken(_ syntax: TokenSyntax) -> NormalFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.equalsToken)
    return NormalFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var rhsExpr: ExprSyntax {
    return child(at: Cursor.rhsExpr) as! ExprSyntax
  }
  public func withRhsExpr(_ syntax: ExprSyntax) -> NormalFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rhsExpr)
    return NormalFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> NormalFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return NormalFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

}

public class TypedParameterArrowExprSyntax: ExprSyntax {
  public enum Cursor: Int {
    case parameters
    case arrowToken
    case outputExpr
  }

  public convenience init(parameters: TypedParameterListSyntax, arrowToken: TokenSyntax, outputExpr: ExprSyntax) {
    let raw = RawSyntax.node(.typedParameterArrowExpr, [
      parameters.raw,
      arrowToken.raw,
      outputExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var parameters: TypedParameterListSyntax {
    return child(at: Cursor.parameters) as! TypedParameterListSyntax
  }
  public func withParameters(_ syntax: TypedParameterListSyntax) -> TypedParameterArrowExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.parameters)
    return TypedParameterArrowExprSyntax(root: newRoot, data: newData)
  }

  public var arrowToken: TokenSyntax {
    return child(at: Cursor.arrowToken) as! TokenSyntax
  }
  public func withArrowToken(_ syntax: TokenSyntax) -> TypedParameterArrowExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.arrowToken)
    return TypedParameterArrowExprSyntax(root: newRoot, data: newData)
  }

  public var outputExpr: ExprSyntax {
    return child(at: Cursor.outputExpr) as! ExprSyntax
  }
  public func withOutputExpr(_ syntax: ExprSyntax) -> TypedParameterArrowExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.outputExpr)
    return TypedParameterArrowExprSyntax(root: newRoot, data: newData)
  }

}

public class LambdaExprSyntax: ExprSyntax {
  public enum Cursor: Int {
    case slashToken
    case bindingList
    case arrowToken
    case bodyExpr
  }

  public convenience init(slashToken: TokenSyntax, bindingList: BindingListSyntax, arrowToken: TokenSyntax, bodyExpr: ExprSyntax) {
    let raw = RawSyntax.node(.lambdaExpr, [
      slashToken.raw,
      bindingList.raw,
      arrowToken.raw,
      bodyExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var slashToken: TokenSyntax {
    return child(at: Cursor.slashToken) as! TokenSyntax
  }
  public func withSlashToken(_ syntax: TokenSyntax) -> LambdaExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.slashToken)
    return LambdaExprSyntax(root: newRoot, data: newData)
  }

  public var bindingList: BindingListSyntax {
    return child(at: Cursor.bindingList) as! BindingListSyntax
  }
  public func withBindingList(_ syntax: BindingListSyntax) -> LambdaExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.bindingList)
    return LambdaExprSyntax(root: newRoot, data: newData)
  }

  public var arrowToken: TokenSyntax {
    return child(at: Cursor.arrowToken) as! TokenSyntax
  }
  public func withArrowToken(_ syntax: TokenSyntax) -> LambdaExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.arrowToken)
    return LambdaExprSyntax(root: newRoot, data: newData)
  }

  public var bodyExpr: ExprSyntax {
    return child(at: Cursor.bodyExpr) as! ExprSyntax
  }
  public func withBodyExpr(_ syntax: ExprSyntax) -> LambdaExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.bodyExpr)
    return LambdaExprSyntax(root: newRoot, data: newData)
  }

}

public class QuantifiedExprSyntax: ExprSyntax {
  public enum Cursor: Int {
    case forallToken
    case bindingList
    case arrowToken
    case outputExpr
  }

  public convenience init(forallToken: TokenSyntax, bindingList: TypedParameterListSyntax, arrowToken: TokenSyntax, outputExpr: ExprSyntax) {
    let raw = RawSyntax.node(.quantifiedExpr, [
      forallToken.raw,
      bindingList.raw,
      arrowToken.raw,
      outputExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var forallToken: TokenSyntax {
    return child(at: Cursor.forallToken) as! TokenSyntax
  }
  public func withForallToken(_ syntax: TokenSyntax) -> QuantifiedExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.forallToken)
    return QuantifiedExprSyntax(root: newRoot, data: newData)
  }

  public var bindingList: TypedParameterListSyntax {
    return child(at: Cursor.bindingList) as! TypedParameterListSyntax
  }
  public func withBindingList(_ syntax: TypedParameterListSyntax) -> QuantifiedExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.bindingList)
    return QuantifiedExprSyntax(root: newRoot, data: newData)
  }

  public var arrowToken: TokenSyntax {
    return child(at: Cursor.arrowToken) as! TokenSyntax
  }
  public func withArrowToken(_ syntax: TokenSyntax) -> QuantifiedExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.arrowToken)
    return QuantifiedExprSyntax(root: newRoot, data: newData)
  }

  public var outputExpr: ExprSyntax {
    return child(at: Cursor.outputExpr) as! ExprSyntax
  }
  public func withOutputExpr(_ syntax: ExprSyntax) -> QuantifiedExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.outputExpr)
    return QuantifiedExprSyntax(root: newRoot, data: newData)
  }

}

public class LetExprSyntax: ExprSyntax {
  public enum Cursor: Int {
    case letToken
    case declList
    case inToken
    case outputExpr
  }

  public convenience init(letToken: TokenSyntax, declList: DeclListSyntax, inToken: TokenSyntax, outputExpr: ExprSyntax) {
    let raw = RawSyntax.node(.letExpr, [
      letToken.raw,
      declList.raw,
      inToken.raw,
      outputExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var letToken: TokenSyntax {
    return child(at: Cursor.letToken) as! TokenSyntax
  }
  public func withLetToken(_ syntax: TokenSyntax) -> LetExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.letToken)
    return LetExprSyntax(root: newRoot, data: newData)
  }

  public var declList: DeclListSyntax {
    return child(at: Cursor.declList) as! DeclListSyntax
  }
  public func withDeclList(_ syntax: DeclListSyntax) -> LetExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.declList)
    return LetExprSyntax(root: newRoot, data: newData)
  }

  public var inToken: TokenSyntax {
    return child(at: Cursor.inToken) as! TokenSyntax
  }
  public func withInToken(_ syntax: TokenSyntax) -> LetExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.inToken)
    return LetExprSyntax(root: newRoot, data: newData)
  }

  public var outputExpr: ExprSyntax {
    return child(at: Cursor.outputExpr) as! ExprSyntax
  }
  public func withOutputExpr(_ syntax: ExprSyntax) -> LetExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.outputExpr)
    return LetExprSyntax(root: newRoot, data: newData)
  }

}

public class ApplicationExprSyntax: ExprSyntax {
  public enum Cursor: Int {
    case exprs
  }

  public convenience init(exprs: BasicExprListSyntax) {
    let raw = RawSyntax.node(.applicationExpr, [
      exprs.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var exprs: BasicExprListSyntax {
    return child(at: Cursor.exprs) as! BasicExprListSyntax
  }
  public func withExprs(_ syntax: BasicExprListSyntax) -> ApplicationExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.exprs)
    return ApplicationExprSyntax(root: newRoot, data: newData)
  }

}

public class BasicExprSyntax: ExprSyntax {

  public convenience init() {
    let raw = RawSyntax.node(.basicExpr, [
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
}

public final class BindingListSyntax: SyntaxCollection<BindingSyntax> {
  internal override init(root: SyntaxData, data: SyntaxData) {
    super.init(root: root, data: data)
  }
  public init(elements: [BindingSyntax]) {
    super.init(kind: .bindingList, elements: elements)
  }
}

public class BindingSyntax: Syntax {

  public convenience init() {
    let raw = RawSyntax.node(.binding, [
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
}

public class NamedBindingSyntax: BindingSyntax {
  public enum Cursor: Int {
    case name
  }

  public convenience init(name: QualifiedNameSyntax) {
    let raw = RawSyntax.node(.namedBinding, [
      name.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var name: QualifiedNameSyntax {
    return child(at: Cursor.name) as! QualifiedNameSyntax
  }
  public func withName(_ syntax: QualifiedNameSyntax) -> NamedBindingSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.name)
    return NamedBindingSyntax(root: newRoot, data: newData)
  }

}

public class TypedBindingSyntax: BindingSyntax {
  public enum Cursor: Int {
    case parameter
  }

  public convenience init(parameter: TypedParameterSyntax) {
    let raw = RawSyntax.node(.typedBinding, [
      parameter.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var parameter: TypedParameterSyntax {
    return child(at: Cursor.parameter) as! TypedParameterSyntax
  }
  public func withParameter(_ syntax: TypedParameterSyntax) -> TypedBindingSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.parameter)
    return TypedBindingSyntax(root: newRoot, data: newData)
  }

}

public final class BasicExprListSyntax: SyntaxCollection<BasicExprSyntax> {
  internal override init(root: SyntaxData, data: SyntaxData) {
    super.init(root: root, data: data)
  }
  public init(elements: [BasicExprSyntax]) {
    super.init(kind: .basicExprList, elements: elements)
  }
}

public class NamedBasicExprSyntax: BasicExprSyntax {
  public enum Cursor: Int {
    case name
  }

  public convenience init(name: QualifiedNameSyntax) {
    let raw = RawSyntax.node(.namedBasicExpr, [
      name.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var name: QualifiedNameSyntax {
    return child(at: Cursor.name) as! QualifiedNameSyntax
  }
  public func withName(_ syntax: QualifiedNameSyntax) -> NamedBasicExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.name)
    return NamedBasicExprSyntax(root: newRoot, data: newData)
  }

}

public class UnderscoreExprSyntax: BasicExprSyntax {
  public enum Cursor: Int {
    case underscoreToken
  }

  public convenience init(underscoreToken: TokenSyntax) {
    let raw = RawSyntax.node(.underscoreExpr, [
      underscoreToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var underscoreToken: TokenSyntax {
    return child(at: Cursor.underscoreToken) as! TokenSyntax
  }
  public func withUnderscoreToken(_ syntax: TokenSyntax) -> UnderscoreExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.underscoreToken)
    return UnderscoreExprSyntax(root: newRoot, data: newData)
  }

}

public class TypeBasicExprSyntax: BasicExprSyntax {
  public enum Cursor: Int {
    case typeToken
  }

  public convenience init(typeToken: TokenSyntax) {
    let raw = RawSyntax.node(.typeBasicExpr, [
      typeToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var typeToken: TokenSyntax {
    return child(at: Cursor.typeToken) as! TokenSyntax
  }
  public func withTypeToken(_ syntax: TokenSyntax) -> TypeBasicExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.typeToken)
    return TypeBasicExprSyntax(root: newRoot, data: newData)
  }

}

public class ParenthesizedExprSyntax: BasicExprSyntax {
  public enum Cursor: Int {
    case leftParenToken
    case expr
    case rightParenToken
  }

  public convenience init(leftParenToken: TokenSyntax, expr: ExprSyntax, rightParenToken: TokenSyntax) {
    let raw = RawSyntax.node(.parenthesizedExpr, [
      leftParenToken.raw,
      expr.raw,
      rightParenToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var leftParenToken: TokenSyntax {
    return child(at: Cursor.leftParenToken) as! TokenSyntax
  }
  public func withLeftParenToken(_ syntax: TokenSyntax) -> ParenthesizedExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.leftParenToken)
    return ParenthesizedExprSyntax(root: newRoot, data: newData)
  }

  public var expr: ExprSyntax {
    return child(at: Cursor.expr) as! ExprSyntax
  }
  public func withExpr(_ syntax: ExprSyntax) -> ParenthesizedExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.expr)
    return ParenthesizedExprSyntax(root: newRoot, data: newData)
  }

  public var rightParenToken: TokenSyntax {
    return child(at: Cursor.rightParenToken) as! TokenSyntax
  }
  public func withRightParenToken(_ syntax: TokenSyntax) -> ParenthesizedExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rightParenToken)
    return ParenthesizedExprSyntax(root: newRoot, data: newData)
  }

}

public class RecordExprSyntax: BasicExprSyntax {
  public enum Cursor: Int {
    case recordToken
    case parameterExpr
    case leftBraceToken
    case fieldAssignments
    case rightBraceToken
  }

  public convenience init(recordToken: TokenSyntax, parameterExpr: BasicExprSyntax?, leftBraceToken: TokenSyntax, fieldAssignments: RecordFieldAssignmentListSyntax, rightBraceToken: TokenSyntax) {
    let raw = RawSyntax.node(.recordExpr, [
      recordToken.raw,
      parameterExpr?.raw ?? RawSyntax.missing(.basicExpr),
      leftBraceToken.raw,
      fieldAssignments.raw,
      rightBraceToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var recordToken: TokenSyntax {
    return child(at: Cursor.recordToken) as! TokenSyntax
  }
  public func withRecordToken(_ syntax: TokenSyntax) -> RecordExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.recordToken)
    return RecordExprSyntax(root: newRoot, data: newData)
  }

  public var parameterExpr: BasicExprSyntax? {
    return child(at: Cursor.parameterExpr) as? BasicExprSyntax
  }
  public func withParameterExpr(_ syntax: BasicExprSyntax) -> RecordExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.parameterExpr)
    return RecordExprSyntax(root: newRoot, data: newData)
  }

  public var leftBraceToken: TokenSyntax {
    return child(at: Cursor.leftBraceToken) as! TokenSyntax
  }
  public func withLeftBraceToken(_ syntax: TokenSyntax) -> RecordExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.leftBraceToken)
    return RecordExprSyntax(root: newRoot, data: newData)
  }

  public var fieldAssignments: RecordFieldAssignmentListSyntax {
    return child(at: Cursor.fieldAssignments) as! RecordFieldAssignmentListSyntax
  }
  public func withFieldAssignments(_ syntax: RecordFieldAssignmentListSyntax) -> RecordExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.fieldAssignments)
    return RecordExprSyntax(root: newRoot, data: newData)
  }

  public var rightBraceToken: TokenSyntax {
    return child(at: Cursor.rightBraceToken) as! TokenSyntax
  }
  public func withRightBraceToken(_ syntax: TokenSyntax) -> RecordExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rightBraceToken)
    return RecordExprSyntax(root: newRoot, data: newData)
  }

}

