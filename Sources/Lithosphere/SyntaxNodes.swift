/// SyntaxNodes.swift
/// Automatically generated by SyntaxGen. Do not edit!
///
/// Copyright 2017-2018, The Silt Language Project.
///
/// This project is released under the MIT license, a copy of which is
/// available in the repository.
public class ExprSyntax: Syntax {}
public class DeclSyntax: Syntax {}
public typealias IdentifierListSyntax = SyntaxCollection<TokenSyntax>

public typealias QualifiedNameSyntax = SyntaxCollection<QualifiedNamePieceSyntax>

public class QualifiedNamePieceSyntax: Syntax {
  public enum Cursor: Int {
    case name
    case trailingPeriod
  }

  public convenience init(name: TokenSyntax, trailingPeriod: TokenSyntax?) {
    let raw = RawSyntax.node(.qualifiedNamePiece, [
      name.raw,
      trailingPeriod?.raw ?? RawSyntax.missingToken(.period),
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var name: TokenSyntax {
    return child(at: Cursor.name) as! TokenSyntax
  }
  public func withName(_ syntax: TokenSyntax) -> QualifiedNamePieceSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.name)
    return QualifiedNamePieceSyntax(root: newRoot, data: newData)
  }

  public var trailingPeriod: TokenSyntax? {
    return child(at: Cursor.trailingPeriod) as? TokenSyntax
  }
  public func withTrailingPeriod(_ syntax: TokenSyntax) -> QualifiedNamePieceSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingPeriod)
    return QualifiedNamePieceSyntax(root: newRoot, data: newData)
  }

}

public class ModuleDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case moduleToken
    case moduleIdentifier
    case typedParameterList
    case whereToken
    case leftBraceToken
    case declList
    case rightBraceToken
    case trailingSemicolon
  }

  public convenience init(moduleToken: TokenSyntax, moduleIdentifier: QualifiedNameSyntax, typedParameterList: TypedParameterListSyntax, whereToken: TokenSyntax, leftBraceToken: TokenSyntax, declList: DeclListSyntax, rightBraceToken: TokenSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.moduleDecl, [
      moduleToken.raw,
      moduleIdentifier.raw,
      typedParameterList.raw,
      whereToken.raw,
      leftBraceToken.raw,
      declList.raw,
      rightBraceToken.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var moduleToken: TokenSyntax {
    return child(at: Cursor.moduleToken) as! TokenSyntax
  }
  public func withModuleToken(_ syntax: TokenSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.moduleToken)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

  public var moduleIdentifier: QualifiedNameSyntax {
    return child(at: Cursor.moduleIdentifier) as! QualifiedNameSyntax
  }
  public func withModuleIdentifier(_ syntax: QualifiedNameSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.moduleIdentifier)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

  public var typedParameterList: TypedParameterListSyntax {
    return child(at: Cursor.typedParameterList) as! TypedParameterListSyntax
  }
  public func withTypedParameterList(_ syntax: TypedParameterListSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.typedParameterList)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

  public var whereToken: TokenSyntax {
    return child(at: Cursor.whereToken) as! TokenSyntax
  }
  public func withWhereToken(_ syntax: TokenSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.whereToken)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

  public var leftBraceToken: TokenSyntax {
    return child(at: Cursor.leftBraceToken) as! TokenSyntax
  }
  public func withLeftBraceToken(_ syntax: TokenSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.leftBraceToken)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

  public var declList: DeclListSyntax {
    return child(at: Cursor.declList) as! DeclListSyntax
  }
  public func withDeclList(_ syntax: DeclListSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.declList)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

  public var rightBraceToken: TokenSyntax {
    return child(at: Cursor.rightBraceToken) as! TokenSyntax
  }
  public func withRightBraceToken(_ syntax: TokenSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rightBraceToken)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

}

public typealias DeclListSyntax = SyntaxCollection<DeclSyntax>

public class OpenImportDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case openToken
    case importToken
    case importIdentifier
  }

  public convenience init(openToken: TokenSyntax?, importToken: TokenSyntax, importIdentifier: QualifiedNameSyntax) {
    let raw = RawSyntax.node(.openImportDecl, [
      openToken?.raw ?? RawSyntax.missingToken(.openKeyword),
      importToken.raw,
      importIdentifier.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var openToken: TokenSyntax? {
    return child(at: Cursor.openToken) as? TokenSyntax
  }
  public func withOpenToken(_ syntax: TokenSyntax) -> OpenImportDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.openToken)
    return OpenImportDeclSyntax(root: newRoot, data: newData)
  }

  public var importToken: TokenSyntax {
    return child(at: Cursor.importToken) as! TokenSyntax
  }
  public func withImportToken(_ syntax: TokenSyntax) -> OpenImportDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.importToken)
    return OpenImportDeclSyntax(root: newRoot, data: newData)
  }

  public var importIdentifier: QualifiedNameSyntax {
    return child(at: Cursor.importIdentifier) as! QualifiedNameSyntax
  }
  public func withImportIdentifier(_ syntax: QualifiedNameSyntax) -> OpenImportDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.importIdentifier)
    return OpenImportDeclSyntax(root: newRoot, data: newData)
  }

}

public class ImportDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case importToken
    case importIdentifier
  }

  public convenience init(importToken: TokenSyntax, importIdentifier: QualifiedNameSyntax) {
    let raw = RawSyntax.node(.importDecl, [
      importToken.raw,
      importIdentifier.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var importToken: TokenSyntax {
    return child(at: Cursor.importToken) as! TokenSyntax
  }
  public func withImportToken(_ syntax: TokenSyntax) -> ImportDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.importToken)
    return ImportDeclSyntax(root: newRoot, data: newData)
  }

  public var importIdentifier: QualifiedNameSyntax {
    return child(at: Cursor.importIdentifier) as! QualifiedNameSyntax
  }
  public func withImportIdentifier(_ syntax: QualifiedNameSyntax) -> ImportDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.importIdentifier)
    return ImportDeclSyntax(root: newRoot, data: newData)
  }

}

public class DataDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case dataToken
    case dataIdentifier
    case typedParameterList
    case typeIndices
    case whereToken
    case leftBraceToken
    case constructorList
    case rightBraceToken
    case trailingSemicolon
  }

  public convenience init(dataToken: TokenSyntax, dataIdentifier: TokenSyntax, typedParameterList: TypedParameterListSyntax, typeIndices: TypeIndicesSyntax, whereToken: TokenSyntax, leftBraceToken: TokenSyntax, constructorList: ConstructorListSyntax, rightBraceToken: TokenSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.dataDecl, [
      dataToken.raw,
      dataIdentifier.raw,
      typedParameterList.raw,
      typeIndices.raw,
      whereToken.raw,
      leftBraceToken.raw,
      constructorList.raw,
      rightBraceToken.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var dataToken: TokenSyntax {
    return child(at: Cursor.dataToken) as! TokenSyntax
  }
  public func withDataToken(_ syntax: TokenSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.dataToken)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var dataIdentifier: TokenSyntax {
    return child(at: Cursor.dataIdentifier) as! TokenSyntax
  }
  public func withDataIdentifier(_ syntax: TokenSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.dataIdentifier)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var typedParameterList: TypedParameterListSyntax {
    return child(at: Cursor.typedParameterList) as! TypedParameterListSyntax
  }
  public func withTypedParameterList(_ syntax: TypedParameterListSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.typedParameterList)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var typeIndices: TypeIndicesSyntax {
    return child(at: Cursor.typeIndices) as! TypeIndicesSyntax
  }
  public func withTypeIndices(_ syntax: TypeIndicesSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.typeIndices)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var whereToken: TokenSyntax {
    return child(at: Cursor.whereToken) as! TokenSyntax
  }
  public func withWhereToken(_ syntax: TokenSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.whereToken)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var leftBraceToken: TokenSyntax {
    return child(at: Cursor.leftBraceToken) as! TokenSyntax
  }
  public func withLeftBraceToken(_ syntax: TokenSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.leftBraceToken)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var constructorList: ConstructorListSyntax {
    return child(at: Cursor.constructorList) as! ConstructorListSyntax
  }
  public func withConstructorList(_ syntax: ConstructorListSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.constructorList)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var rightBraceToken: TokenSyntax {
    return child(at: Cursor.rightBraceToken) as! TokenSyntax
  }
  public func withRightBraceToken(_ syntax: TokenSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rightBraceToken)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

}

public class EmptyDataDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case dataToken
    case dataIdentifier
    case typedParameterList
    case typeIndices
    case trailingSemicolon
  }

  public convenience init(dataToken: TokenSyntax, dataIdentifier: TokenSyntax, typedParameterList: TypedParameterListSyntax, typeIndices: TypeIndicesSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.emptyDataDecl, [
      dataToken.raw,
      dataIdentifier.raw,
      typedParameterList.raw,
      typeIndices.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var dataToken: TokenSyntax {
    return child(at: Cursor.dataToken) as! TokenSyntax
  }
  public func withDataToken(_ syntax: TokenSyntax) -> EmptyDataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.dataToken)
    return EmptyDataDeclSyntax(root: newRoot, data: newData)
  }

  public var dataIdentifier: TokenSyntax {
    return child(at: Cursor.dataIdentifier) as! TokenSyntax
  }
  public func withDataIdentifier(_ syntax: TokenSyntax) -> EmptyDataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.dataIdentifier)
    return EmptyDataDeclSyntax(root: newRoot, data: newData)
  }

  public var typedParameterList: TypedParameterListSyntax {
    return child(at: Cursor.typedParameterList) as! TypedParameterListSyntax
  }
  public func withTypedParameterList(_ syntax: TypedParameterListSyntax) -> EmptyDataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.typedParameterList)
    return EmptyDataDeclSyntax(root: newRoot, data: newData)
  }

  public var typeIndices: TypeIndicesSyntax {
    return child(at: Cursor.typeIndices) as! TypeIndicesSyntax
  }
  public func withTypeIndices(_ syntax: TypeIndicesSyntax) -> EmptyDataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.typeIndices)
    return EmptyDataDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> EmptyDataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return EmptyDataDeclSyntax(root: newRoot, data: newData)
  }

}

public class TypeIndicesSyntax: Syntax {
  public enum Cursor: Int {
    case colonToken
    case indexExpr
  }

  public convenience init(colonToken: TokenSyntax, indexExpr: ExprSyntax) {
    let raw = RawSyntax.node(.typeIndices, [
      colonToken.raw,
      indexExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var colonToken: TokenSyntax {
    return child(at: Cursor.colonToken) as! TokenSyntax
  }
  public func withColonToken(_ syntax: TokenSyntax) -> TypeIndicesSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.colonToken)
    return TypeIndicesSyntax(root: newRoot, data: newData)
  }

  public var indexExpr: ExprSyntax {
    return child(at: Cursor.indexExpr) as! ExprSyntax
  }
  public func withIndexExpr(_ syntax: ExprSyntax) -> TypeIndicesSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.indexExpr)
    return TypeIndicesSyntax(root: newRoot, data: newData)
  }

}

public typealias TypedParameterListSyntax = SyntaxCollection<TypedParameterSyntax>

public class AscriptionSyntax: Syntax {
  public enum Cursor: Int {
    case boundNames
    case colonToken
    case typeExpr
  }

  public convenience init(boundNames: IdentifierListSyntax, colonToken: TokenSyntax, typeExpr: ExprSyntax) {
    let raw = RawSyntax.node(.ascription, [
      boundNames.raw,
      colonToken.raw,
      typeExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var boundNames: IdentifierListSyntax {
    return child(at: Cursor.boundNames) as! IdentifierListSyntax
  }
  public func withBoundNames(_ syntax: IdentifierListSyntax) -> AscriptionSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.boundNames)
    return AscriptionSyntax(root: newRoot, data: newData)
  }

  public var colonToken: TokenSyntax {
    return child(at: Cursor.colonToken) as! TokenSyntax
  }
  public func withColonToken(_ syntax: TokenSyntax) -> AscriptionSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.colonToken)
    return AscriptionSyntax(root: newRoot, data: newData)
  }

  public var typeExpr: ExprSyntax {
    return child(at: Cursor.typeExpr) as! ExprSyntax
  }
  public func withTypeExpr(_ syntax: ExprSyntax) -> AscriptionSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.typeExpr)
    return AscriptionSyntax(root: newRoot, data: newData)
  }

}

public class TypedParameterSyntax: Syntax {

  public convenience init() {
    let raw = RawSyntax.node(.typedParameter, [
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
}

public class ExplicitTypedParameterSyntax: TypedParameterSyntax {
  public enum Cursor: Int {
    case leftParenToken
    case ascription
    case rightParenToken
  }

  public convenience init(leftParenToken: TokenSyntax, ascription: AscriptionSyntax, rightParenToken: TokenSyntax) {
    let raw = RawSyntax.node(.explicitTypedParameter, [
      leftParenToken.raw,
      ascription.raw,
      rightParenToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var leftParenToken: TokenSyntax {
    return child(at: Cursor.leftParenToken) as! TokenSyntax
  }
  public func withLeftParenToken(_ syntax: TokenSyntax) -> ExplicitTypedParameterSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.leftParenToken)
    return ExplicitTypedParameterSyntax(root: newRoot, data: newData)
  }

  public var ascription: AscriptionSyntax {
    return child(at: Cursor.ascription) as! AscriptionSyntax
  }
  public func withAscription(_ syntax: AscriptionSyntax) -> ExplicitTypedParameterSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.ascription)
    return ExplicitTypedParameterSyntax(root: newRoot, data: newData)
  }

  public var rightParenToken: TokenSyntax {
    return child(at: Cursor.rightParenToken) as! TokenSyntax
  }
  public func withRightParenToken(_ syntax: TokenSyntax) -> ExplicitTypedParameterSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rightParenToken)
    return ExplicitTypedParameterSyntax(root: newRoot, data: newData)
  }

}

public class ImplicitTypedParameterSyntax: TypedParameterSyntax {
  public enum Cursor: Int {
    case leftBraceToken
    case ascription
    case rightBraceToken
  }

  public convenience init(leftBraceToken: TokenSyntax, ascription: AscriptionSyntax, rightBraceToken: TokenSyntax) {
    let raw = RawSyntax.node(.implicitTypedParameter, [
      leftBraceToken.raw,
      ascription.raw,
      rightBraceToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var leftBraceToken: TokenSyntax {
    return child(at: Cursor.leftBraceToken) as! TokenSyntax
  }
  public func withLeftBraceToken(_ syntax: TokenSyntax) -> ImplicitTypedParameterSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.leftBraceToken)
    return ImplicitTypedParameterSyntax(root: newRoot, data: newData)
  }

  public var ascription: AscriptionSyntax {
    return child(at: Cursor.ascription) as! AscriptionSyntax
  }
  public func withAscription(_ syntax: AscriptionSyntax) -> ImplicitTypedParameterSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.ascription)
    return ImplicitTypedParameterSyntax(root: newRoot, data: newData)
  }

  public var rightBraceToken: TokenSyntax {
    return child(at: Cursor.rightBraceToken) as! TokenSyntax
  }
  public func withRightBraceToken(_ syntax: TokenSyntax) -> ImplicitTypedParameterSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rightBraceToken)
    return ImplicitTypedParameterSyntax(root: newRoot, data: newData)
  }

}

public typealias ConstructorListSyntax = SyntaxCollection<ConstructorDeclSyntax>

public class ConstructorDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case ascription
    case trailingSemicolon
  }

  public convenience init(ascription: AscriptionSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.constructorDecl, [
      ascription.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var ascription: AscriptionSyntax {
    return child(at: Cursor.ascription) as! AscriptionSyntax
  }
  public func withAscription(_ syntax: AscriptionSyntax) -> ConstructorDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.ascription)
    return ConstructorDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> ConstructorDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return ConstructorDeclSyntax(root: newRoot, data: newData)
  }

}

public class RecordDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case recordToken
    case recordName
    case parameterList
    case typeIndices
    case whereToken
    case leftParenToken
    case recordElementList
    case rightParenToken
    case trailingSemicolon
  }

  public convenience init(recordToken: TokenSyntax, recordName: TokenSyntax, parameterList: TypedParameterListSyntax, typeIndices: TypeIndicesSyntax?, whereToken: TokenSyntax, leftParenToken: TokenSyntax, recordElementList: DeclListSyntax, rightParenToken: TokenSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.recordDecl, [
      recordToken.raw,
      recordName.raw,
      parameterList.raw,
      typeIndices?.raw ?? RawSyntax.missing(.typeIndices),
      whereToken.raw,
      leftParenToken.raw,
      recordElementList.raw,
      rightParenToken.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var recordToken: TokenSyntax {
    return child(at: Cursor.recordToken) as! TokenSyntax
  }
  public func withRecordToken(_ syntax: TokenSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.recordToken)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

  public var recordName: TokenSyntax {
    return child(at: Cursor.recordName) as! TokenSyntax
  }
  public func withRecordName(_ syntax: TokenSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.recordName)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

  public var parameterList: TypedParameterListSyntax {
    return child(at: Cursor.parameterList) as! TypedParameterListSyntax
  }
  public func withParameterList(_ syntax: TypedParameterListSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.parameterList)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

  public var typeIndices: TypeIndicesSyntax? {
    return child(at: Cursor.typeIndices) as? TypeIndicesSyntax
  }
  public func withTypeIndices(_ syntax: TypeIndicesSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.typeIndices)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

  public var whereToken: TokenSyntax {
    return child(at: Cursor.whereToken) as! TokenSyntax
  }
  public func withWhereToken(_ syntax: TokenSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.whereToken)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

  public var leftParenToken: TokenSyntax {
    return child(at: Cursor.leftParenToken) as! TokenSyntax
  }
  public func withLeftParenToken(_ syntax: TokenSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.leftParenToken)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

  public var recordElementList: DeclListSyntax {
    return child(at: Cursor.recordElementList) as! DeclListSyntax
  }
  public func withRecordElementList(_ syntax: DeclListSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.recordElementList)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

  public var rightParenToken: TokenSyntax {
    return child(at: Cursor.rightParenToken) as! TokenSyntax
  }
  public func withRightParenToken(_ syntax: TokenSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rightParenToken)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

}

public class FieldDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case fieldToken
    case ascription
    case trailingSemicolon
  }

  public convenience init(fieldToken: TokenSyntax, ascription: AscriptionSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.fieldDecl, [
      fieldToken.raw,
      ascription.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var fieldToken: TokenSyntax {
    return child(at: Cursor.fieldToken) as! TokenSyntax
  }
  public func withFieldToken(_ syntax: TokenSyntax) -> FieldDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.fieldToken)
    return FieldDeclSyntax(root: newRoot, data: newData)
  }

  public var ascription: AscriptionSyntax {
    return child(at: Cursor.ascription) as! AscriptionSyntax
  }
  public func withAscription(_ syntax: AscriptionSyntax) -> FieldDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.ascription)
    return FieldDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> FieldDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return FieldDeclSyntax(root: newRoot, data: newData)
  }

}

public class RecordConstructorDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case constructorToken
    case constructorName
    case trailingSemicolon
  }

  public convenience init(constructorToken: TokenSyntax, constructorName: TokenSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.recordConstructorDecl, [
      constructorToken.raw,
      constructorName.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var constructorToken: TokenSyntax {
    return child(at: Cursor.constructorToken) as! TokenSyntax
  }
  public func withConstructorToken(_ syntax: TokenSyntax) -> RecordConstructorDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.constructorToken)
    return RecordConstructorDeclSyntax(root: newRoot, data: newData)
  }

  public var constructorName: TokenSyntax {
    return child(at: Cursor.constructorName) as! TokenSyntax
  }
  public func withConstructorName(_ syntax: TokenSyntax) -> RecordConstructorDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.constructorName)
    return RecordConstructorDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> RecordConstructorDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return RecordConstructorDeclSyntax(root: newRoot, data: newData)
  }

}

public typealias RecordFieldAssignmentListSyntax = SyntaxCollection<RecordFieldAssignmentSyntax>

public class RecordFieldAssignmentSyntax: Syntax {
  public enum Cursor: Int {
    case fieldName
    case equalsToken
    case fieldInitExpr
    case trailingSemicolon
  }

  public convenience init(fieldName: TokenSyntax, equalsToken: TokenSyntax, fieldInitExpr: ExprSyntax, trailingSemicolon: TokenSyntax?) {
    let raw = RawSyntax.node(.recordFieldAssignment, [
      fieldName.raw,
      equalsToken.raw,
      fieldInitExpr.raw,
      trailingSemicolon?.raw ?? RawSyntax.missingToken(.semicolon),
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var fieldName: TokenSyntax {
    return child(at: Cursor.fieldName) as! TokenSyntax
  }
  public func withFieldName(_ syntax: TokenSyntax) -> RecordFieldAssignmentSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.fieldName)
    return RecordFieldAssignmentSyntax(root: newRoot, data: newData)
  }

  public var equalsToken: TokenSyntax {
    return child(at: Cursor.equalsToken) as! TokenSyntax
  }
  public func withEqualsToken(_ syntax: TokenSyntax) -> RecordFieldAssignmentSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.equalsToken)
    return RecordFieldAssignmentSyntax(root: newRoot, data: newData)
  }

  public var fieldInitExpr: ExprSyntax {
    return child(at: Cursor.fieldInitExpr) as! ExprSyntax
  }
  public func withFieldInitExpr(_ syntax: ExprSyntax) -> RecordFieldAssignmentSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.fieldInitExpr)
    return RecordFieldAssignmentSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax? {
    return child(at: Cursor.trailingSemicolon) as? TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> RecordFieldAssignmentSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return RecordFieldAssignmentSyntax(root: newRoot, data: newData)
  }

}

public class FunctionDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case ascription
    case trailingSemicolon
  }

  public convenience init(ascription: AscriptionSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.functionDecl, [
      ascription.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var ascription: AscriptionSyntax {
    return child(at: Cursor.ascription) as! AscriptionSyntax
  }
  public func withAscription(_ syntax: AscriptionSyntax) -> FunctionDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.ascription)
    return FunctionDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> FunctionDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return FunctionDeclSyntax(root: newRoot, data: newData)
  }

}

public class FunctionClauseDeclSyntax: DeclSyntax {

  public convenience init() {
    let raw = RawSyntax.node(.functionClauseDecl, [
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
}

public class WithRuleFunctionClauseDeclSyntax: FunctionClauseDeclSyntax {
  public enum Cursor: Int {
    case basicExprList
    case withToken
    case withExpr
    case withPatternClause
    case equalsToken
    case rhsExpr
    case trailingSemicolon
  }

  public convenience init(basicExprList: BasicExprListSyntax, withToken: TokenSyntax, withExpr: ExprSyntax, withPatternClause: BasicExprListSyntax?, equalsToken: TokenSyntax, rhsExpr: ExprSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.withRuleFunctionClauseDecl, [
      basicExprList.raw,
      withToken.raw,
      withExpr.raw,
      withPatternClause?.raw ?? RawSyntax.missing(.basicExprList),
      equalsToken.raw,
      rhsExpr.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var basicExprList: BasicExprListSyntax {
    return child(at: Cursor.basicExprList) as! BasicExprListSyntax
  }
  public func withBasicExprList(_ syntax: BasicExprListSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.basicExprList)
    return WithRuleFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var withToken: TokenSyntax {
    return child(at: Cursor.withToken) as! TokenSyntax
  }
  public func withWithToken(_ syntax: TokenSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.withToken)
    return WithRuleFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var withExpr: ExprSyntax {
    return child(at: Cursor.withExpr) as! ExprSyntax
  }
  public func withWithExpr(_ syntax: ExprSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.withExpr)
    return WithRuleFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var withPatternClause: BasicExprListSyntax? {
    return child(at: Cursor.withPatternClause) as? BasicExprListSyntax
  }
  public func withWithPatternClause(_ syntax: BasicExprListSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.withPatternClause)
    return WithRuleFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var equalsToken: TokenSyntax {
    return child(at: Cursor.equalsToken) as! TokenSyntax
  }
  public func withEqualsToken(_ syntax: TokenSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.equalsToken)
    return WithRuleFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var rhsExpr: ExprSyntax {
    return child(at: Cursor.rhsExpr) as! ExprSyntax
  }
  public func withRhsExpr(_ syntax: ExprSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rhsExpr)
    return WithRuleFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return WithRuleFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

}

public class NormalFunctionClauseDeclSyntax: FunctionClauseDeclSyntax {
  public enum Cursor: Int {
    case basicExprList
    case equalsToken
    case rhsExpr
    case trailingSemicolon
  }

  public convenience init(basicExprList: BasicExprListSyntax, equalsToken: TokenSyntax, rhsExpr: ExprSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.normalFunctionClauseDecl, [
      basicExprList.raw,
      equalsToken.raw,
      rhsExpr.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var basicExprList: BasicExprListSyntax {
    return child(at: Cursor.basicExprList) as! BasicExprListSyntax
  }
  public func withBasicExprList(_ syntax: BasicExprListSyntax) -> NormalFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.basicExprList)
    return NormalFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var equalsToken: TokenSyntax {
    return child(at: Cursor.equalsToken) as! TokenSyntax
  }
  public func withEqualsToken(_ syntax: TokenSyntax) -> NormalFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.equalsToken)
    return NormalFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var rhsExpr: ExprSyntax {
    return child(at: Cursor.rhsExpr) as! ExprSyntax
  }
  public func withRhsExpr(_ syntax: ExprSyntax) -> NormalFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rhsExpr)
    return NormalFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> NormalFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return NormalFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

}

public class FixityDeclSyntax: DeclSyntax {

  public convenience init() {
    let raw = RawSyntax.node(.fixityDecl, [
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
}

public class NonFixDeclSyntax: FixityDeclSyntax {
  public enum Cursor: Int {
    case infixToken
    case precedence
    case names
    case trailingSemicolon
  }

  public convenience init(infixToken: TokenSyntax, precedence: TokenSyntax, names: IdentifierListSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.nonFixDecl, [
      infixToken.raw,
      precedence.raw,
      names.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var infixToken: TokenSyntax {
    return child(at: Cursor.infixToken) as! TokenSyntax
  }
  public func withInfixToken(_ syntax: TokenSyntax) -> NonFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.infixToken)
    return NonFixDeclSyntax(root: newRoot, data: newData)
  }

  public var precedence: TokenSyntax {
    return child(at: Cursor.precedence) as! TokenSyntax
  }
  public func withPrecedence(_ syntax: TokenSyntax) -> NonFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.precedence)
    return NonFixDeclSyntax(root: newRoot, data: newData)
  }

  public var names: IdentifierListSyntax {
    return child(at: Cursor.names) as! IdentifierListSyntax
  }
  public func withNames(_ syntax: IdentifierListSyntax) -> NonFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.names)
    return NonFixDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> NonFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return NonFixDeclSyntax(root: newRoot, data: newData)
  }

}

public class LeftFixDeclSyntax: FixityDeclSyntax {
  public enum Cursor: Int {
    case infixlToken
    case precedence
    case names
    case trailingSemicolon
  }

  public convenience init(infixlToken: TokenSyntax, precedence: TokenSyntax, names: IdentifierListSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.leftFixDecl, [
      infixlToken.raw,
      precedence.raw,
      names.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var infixlToken: TokenSyntax {
    return child(at: Cursor.infixlToken) as! TokenSyntax
  }
  public func withInfixlToken(_ syntax: TokenSyntax) -> LeftFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.infixlToken)
    return LeftFixDeclSyntax(root: newRoot, data: newData)
  }

  public var precedence: TokenSyntax {
    return child(at: Cursor.precedence) as! TokenSyntax
  }
  public func withPrecedence(_ syntax: TokenSyntax) -> LeftFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.precedence)
    return LeftFixDeclSyntax(root: newRoot, data: newData)
  }

  public var names: IdentifierListSyntax {
    return child(at: Cursor.names) as! IdentifierListSyntax
  }
  public func withNames(_ syntax: IdentifierListSyntax) -> LeftFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.names)
    return LeftFixDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> LeftFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return LeftFixDeclSyntax(root: newRoot, data: newData)
  }

}

public class RightFixDeclSyntax: FixityDeclSyntax {
  public enum Cursor: Int {
    case infixrToken
    case precedence
    case names
    case trailingSemicolon
  }

  public convenience init(infixrToken: TokenSyntax, precedence: TokenSyntax, names: IdentifierListSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.rightFixDecl, [
      infixrToken.raw,
      precedence.raw,
      names.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var infixrToken: TokenSyntax {
    return child(at: Cursor.infixrToken) as! TokenSyntax
  }
  public func withInfixrToken(_ syntax: TokenSyntax) -> RightFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.infixrToken)
    return RightFixDeclSyntax(root: newRoot, data: newData)
  }

  public var precedence: TokenSyntax {
    return child(at: Cursor.precedence) as! TokenSyntax
  }
  public func withPrecedence(_ syntax: TokenSyntax) -> RightFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.precedence)
    return RightFixDeclSyntax(root: newRoot, data: newData)
  }

  public var names: IdentifierListSyntax {
    return child(at: Cursor.names) as! IdentifierListSyntax
  }
  public func withNames(_ syntax: IdentifierListSyntax) -> RightFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.names)
    return RightFixDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> RightFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return RightFixDeclSyntax(root: newRoot, data: newData)
  }

}

public typealias PatternClauseListSyntax = SyntaxCollection<ExprSyntax>

public class LambdaExprSyntax: ExprSyntax {
  public enum Cursor: Int {
    case slashToken
    case bindingList
    case arrowToken
    case bodyExpr
  }

  public convenience init(slashToken: TokenSyntax, bindingList: BindingListSyntax, arrowToken: TokenSyntax, bodyExpr: ExprSyntax) {
    let raw = RawSyntax.node(.lambdaExpr, [
      slashToken.raw,
      bindingList.raw,
      arrowToken.raw,
      bodyExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var slashToken: TokenSyntax {
    return child(at: Cursor.slashToken) as! TokenSyntax
  }
  public func withSlashToken(_ syntax: TokenSyntax) -> LambdaExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.slashToken)
    return LambdaExprSyntax(root: newRoot, data: newData)
  }

  public var bindingList: BindingListSyntax {
    return child(at: Cursor.bindingList) as! BindingListSyntax
  }
  public func withBindingList(_ syntax: BindingListSyntax) -> LambdaExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.bindingList)
    return LambdaExprSyntax(root: newRoot, data: newData)
  }

  public var arrowToken: TokenSyntax {
    return child(at: Cursor.arrowToken) as! TokenSyntax
  }
  public func withArrowToken(_ syntax: TokenSyntax) -> LambdaExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.arrowToken)
    return LambdaExprSyntax(root: newRoot, data: newData)
  }

  public var bodyExpr: ExprSyntax {
    return child(at: Cursor.bodyExpr) as! ExprSyntax
  }
  public func withBodyExpr(_ syntax: ExprSyntax) -> LambdaExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.bodyExpr)
    return LambdaExprSyntax(root: newRoot, data: newData)
  }

}

public class QuantifiedExprSyntax: ExprSyntax {
  public enum Cursor: Int {
    case forallToken
    case bindingList
    case arrowToken
    case outputExpr
  }

  public convenience init(forallToken: TokenSyntax, bindingList: TypedParameterListSyntax, arrowToken: TokenSyntax, outputExpr: ExprSyntax) {
    let raw = RawSyntax.node(.quantifiedExpr, [
      forallToken.raw,
      bindingList.raw,
      arrowToken.raw,
      outputExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var forallToken: TokenSyntax {
    return child(at: Cursor.forallToken) as! TokenSyntax
  }
  public func withForallToken(_ syntax: TokenSyntax) -> QuantifiedExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.forallToken)
    return QuantifiedExprSyntax(root: newRoot, data: newData)
  }

  public var bindingList: TypedParameterListSyntax {
    return child(at: Cursor.bindingList) as! TypedParameterListSyntax
  }
  public func withBindingList(_ syntax: TypedParameterListSyntax) -> QuantifiedExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.bindingList)
    return QuantifiedExprSyntax(root: newRoot, data: newData)
  }

  public var arrowToken: TokenSyntax {
    return child(at: Cursor.arrowToken) as! TokenSyntax
  }
  public func withArrowToken(_ syntax: TokenSyntax) -> QuantifiedExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.arrowToken)
    return QuantifiedExprSyntax(root: newRoot, data: newData)
  }

  public var outputExpr: ExprSyntax {
    return child(at: Cursor.outputExpr) as! ExprSyntax
  }
  public func withOutputExpr(_ syntax: ExprSyntax) -> QuantifiedExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.outputExpr)
    return QuantifiedExprSyntax(root: newRoot, data: newData)
  }

}

public class LetExprSyntax: ExprSyntax {
  public enum Cursor: Int {
    case letToken
    case declList
    case inToken
    case outputExpr
  }

  public convenience init(letToken: TokenSyntax, declList: DeclListSyntax, inToken: TokenSyntax, outputExpr: ExprSyntax) {
    let raw = RawSyntax.node(.letExpr, [
      letToken.raw,
      declList.raw,
      inToken.raw,
      outputExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var letToken: TokenSyntax {
    return child(at: Cursor.letToken) as! TokenSyntax
  }
  public func withLetToken(_ syntax: TokenSyntax) -> LetExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.letToken)
    return LetExprSyntax(root: newRoot, data: newData)
  }

  public var declList: DeclListSyntax {
    return child(at: Cursor.declList) as! DeclListSyntax
  }
  public func withDeclList(_ syntax: DeclListSyntax) -> LetExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.declList)
    return LetExprSyntax(root: newRoot, data: newData)
  }

  public var inToken: TokenSyntax {
    return child(at: Cursor.inToken) as! TokenSyntax
  }
  public func withInToken(_ syntax: TokenSyntax) -> LetExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.inToken)
    return LetExprSyntax(root: newRoot, data: newData)
  }

  public var outputExpr: ExprSyntax {
    return child(at: Cursor.outputExpr) as! ExprSyntax
  }
  public func withOutputExpr(_ syntax: ExprSyntax) -> LetExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.outputExpr)
    return LetExprSyntax(root: newRoot, data: newData)
  }

}

public class ApplicationExprSyntax: ExprSyntax {
  public enum Cursor: Int {
    case exprs
  }

  public convenience init(exprs: BasicExprListSyntax) {
    let raw = RawSyntax.node(.applicationExpr, [
      exprs.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var exprs: BasicExprListSyntax {
    return child(at: Cursor.exprs) as! BasicExprListSyntax
  }
  public func withExprs(_ syntax: BasicExprListSyntax) -> ApplicationExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.exprs)
    return ApplicationExprSyntax(root: newRoot, data: newData)
  }

}

public class BasicExprSyntax: ExprSyntax {

  public convenience init() {
    let raw = RawSyntax.node(.basicExpr, [
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
}

public typealias BindingListSyntax = SyntaxCollection<BindingSyntax>

public class BindingSyntax: Syntax {

  public convenience init() {
    let raw = RawSyntax.node(.binding, [
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
}

public class NamedBindingSyntax: BindingSyntax {
  public enum Cursor: Int {
    case name
  }

  public convenience init(name: QualifiedNameSyntax) {
    let raw = RawSyntax.node(.namedBinding, [
      name.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var name: QualifiedNameSyntax {
    return child(at: Cursor.name) as! QualifiedNameSyntax
  }
  public func withName(_ syntax: QualifiedNameSyntax) -> NamedBindingSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.name)
    return NamedBindingSyntax(root: newRoot, data: newData)
  }

}

public class TypedBindingSyntax: BindingSyntax {
  public enum Cursor: Int {
    case parameter
  }

  public convenience init(parameter: TypedParameterSyntax) {
    let raw = RawSyntax.node(.typedBinding, [
      parameter.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var parameter: TypedParameterSyntax {
    return child(at: Cursor.parameter) as! TypedParameterSyntax
  }
  public func withParameter(_ syntax: TypedParameterSyntax) -> TypedBindingSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.parameter)
    return TypedBindingSyntax(root: newRoot, data: newData)
  }

}

public typealias BasicExprListSyntax = SyntaxCollection<BasicExprSyntax>

public class NamedBasicExprSyntax: BasicExprSyntax {
  public enum Cursor: Int {
    case name
  }

  public convenience init(name: QualifiedNameSyntax) {
    let raw = RawSyntax.node(.namedBasicExpr, [
      name.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var name: QualifiedNameSyntax {
    return child(at: Cursor.name) as! QualifiedNameSyntax
  }
  public func withName(_ syntax: QualifiedNameSyntax) -> NamedBasicExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.name)
    return NamedBasicExprSyntax(root: newRoot, data: newData)
  }

}

public class UnderscoreExprSyntax: BasicExprSyntax {
  public enum Cursor: Int {
    case underscoreToken
  }

  public convenience init(underscoreToken: TokenSyntax) {
    let raw = RawSyntax.node(.underscoreExpr, [
      underscoreToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var underscoreToken: TokenSyntax {
    return child(at: Cursor.underscoreToken) as! TokenSyntax
  }
  public func withUnderscoreToken(_ syntax: TokenSyntax) -> UnderscoreExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.underscoreToken)
    return UnderscoreExprSyntax(root: newRoot, data: newData)
  }

}

public class TypeBasicExprSyntax: BasicExprSyntax {
  public enum Cursor: Int {
    case typeToken
  }

  public convenience init(typeToken: TokenSyntax) {
    let raw = RawSyntax.node(.typeBasicExpr, [
      typeToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var typeToken: TokenSyntax {
    return child(at: Cursor.typeToken) as! TokenSyntax
  }
  public func withTypeToken(_ syntax: TokenSyntax) -> TypeBasicExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.typeToken)
    return TypeBasicExprSyntax(root: newRoot, data: newData)
  }

}

public class ParenthesizedExprSyntax: BasicExprSyntax {
  public enum Cursor: Int {
    case leftParenToken
    case expr
    case rightParenToken
  }

  public convenience init(leftParenToken: TokenSyntax, expr: ExprSyntax, rightParenToken: TokenSyntax) {
    let raw = RawSyntax.node(.parenthesizedExpr, [
      leftParenToken.raw,
      expr.raw,
      rightParenToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var leftParenToken: TokenSyntax {
    return child(at: Cursor.leftParenToken) as! TokenSyntax
  }
  public func withLeftParenToken(_ syntax: TokenSyntax) -> ParenthesizedExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.leftParenToken)
    return ParenthesizedExprSyntax(root: newRoot, data: newData)
  }

  public var expr: ExprSyntax {
    return child(at: Cursor.expr) as! ExprSyntax
  }
  public func withExpr(_ syntax: ExprSyntax) -> ParenthesizedExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.expr)
    return ParenthesizedExprSyntax(root: newRoot, data: newData)
  }

  public var rightParenToken: TokenSyntax {
    return child(at: Cursor.rightParenToken) as! TokenSyntax
  }
  public func withRightParenToken(_ syntax: TokenSyntax) -> ParenthesizedExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rightParenToken)
    return ParenthesizedExprSyntax(root: newRoot, data: newData)
  }

}

public class TypedParameterGroupExprSyntax: BasicExprSyntax {
  public enum Cursor: Int {
    case parameters
  }

  public convenience init(parameters: TypedParameterListSyntax) {
    let raw = RawSyntax.node(.typedParameterGroupExpr, [
      parameters.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var parameters: TypedParameterListSyntax {
    return child(at: Cursor.parameters) as! TypedParameterListSyntax
  }
  public func withParameters(_ syntax: TypedParameterListSyntax) -> TypedParameterGroupExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.parameters)
    return TypedParameterGroupExprSyntax(root: newRoot, data: newData)
  }

}

public class RecordExprSyntax: BasicExprSyntax {
  public enum Cursor: Int {
    case recordToken
    case parameterExpr
    case leftBraceToken
    case fieldAssignments
    case rightBraceToken
  }

  public convenience init(recordToken: TokenSyntax, parameterExpr: BasicExprSyntax?, leftBraceToken: TokenSyntax, fieldAssignments: RecordFieldAssignmentListSyntax, rightBraceToken: TokenSyntax) {
    let raw = RawSyntax.node(.recordExpr, [
      recordToken.raw,
      parameterExpr?.raw ?? RawSyntax.missing(.basicExpr),
      leftBraceToken.raw,
      fieldAssignments.raw,
      rightBraceToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var recordToken: TokenSyntax {
    return child(at: Cursor.recordToken) as! TokenSyntax
  }
  public func withRecordToken(_ syntax: TokenSyntax) -> RecordExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.recordToken)
    return RecordExprSyntax(root: newRoot, data: newData)
  }

  public var parameterExpr: BasicExprSyntax? {
    return child(at: Cursor.parameterExpr) as? BasicExprSyntax
  }
  public func withParameterExpr(_ syntax: BasicExprSyntax) -> RecordExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.parameterExpr)
    return RecordExprSyntax(root: newRoot, data: newData)
  }

  public var leftBraceToken: TokenSyntax {
    return child(at: Cursor.leftBraceToken) as! TokenSyntax
  }
  public func withLeftBraceToken(_ syntax: TokenSyntax) -> RecordExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.leftBraceToken)
    return RecordExprSyntax(root: newRoot, data: newData)
  }

  public var fieldAssignments: RecordFieldAssignmentListSyntax {
    return child(at: Cursor.fieldAssignments) as! RecordFieldAssignmentListSyntax
  }
  public func withFieldAssignments(_ syntax: RecordFieldAssignmentListSyntax) -> RecordExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.fieldAssignments)
    return RecordExprSyntax(root: newRoot, data: newData)
  }

  public var rightBraceToken: TokenSyntax {
    return child(at: Cursor.rightBraceToken) as! TokenSyntax
  }
  public func withRightBraceToken(_ syntax: TokenSyntax) -> RecordExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rightBraceToken)
    return RecordExprSyntax(root: newRoot, data: newData)
  }

}

public typealias FunctionClauseListSyntax = SyntaxCollection<FunctionClauseDeclSyntax>

public class ReparsedFunctionDeclSyntax: DeclSyntax {
  public enum Cursor: Int {
    case ascription
    case trailingSemicolon
    case clauseList
  }

  public convenience init(ascription: AscriptionSyntax, trailingSemicolon: TokenSyntax, clauseList: FunctionClauseListSyntax) {
    let raw = RawSyntax.node(.reparsedFunctionDecl, [
      ascription.raw,
      trailingSemicolon.raw,
      clauseList.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var ascription: AscriptionSyntax {
    return child(at: Cursor.ascription) as! AscriptionSyntax
  }
  public func withAscription(_ syntax: AscriptionSyntax) -> ReparsedFunctionDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.ascription)
    return ReparsedFunctionDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> ReparsedFunctionDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return ReparsedFunctionDeclSyntax(root: newRoot, data: newData)
  }

  public var clauseList: FunctionClauseListSyntax {
    return child(at: Cursor.clauseList) as! FunctionClauseListSyntax
  }
  public func withClauseList(_ syntax: FunctionClauseListSyntax) -> ReparsedFunctionDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.clauseList)
    return ReparsedFunctionDeclSyntax(root: newRoot, data: newData)
  }

}

public class ReparsedApplicationExprSyntax: BasicExprSyntax {
  public enum Cursor: Int {
    case head
    case exprs
  }

  public convenience init(head: NamedBasicExprSyntax, exprs: BasicExprListSyntax) {
    let raw = RawSyntax.node(.reparsedApplicationExpr, [
      head.raw,
      exprs.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var head: NamedBasicExprSyntax {
    return child(at: Cursor.head) as! NamedBasicExprSyntax
  }
  public func withHead(_ syntax: NamedBasicExprSyntax) -> ReparsedApplicationExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.head)
    return ReparsedApplicationExprSyntax(root: newRoot, data: newData)
  }

  public var exprs: BasicExprListSyntax {
    return child(at: Cursor.exprs) as! BasicExprListSyntax
  }
  public func withExprs(_ syntax: BasicExprListSyntax) -> ReparsedApplicationExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.exprs)
    return ReparsedApplicationExprSyntax(root: newRoot, data: newData)
  }

}

extension SyntaxCollection {
  static var syntaxCollectionKinds: [ObjectIdentifier: SyntaxKind] {
    return [
      ObjectIdentifier(TokenSyntax.self): .identifierList, 
      ObjectIdentifier(QualifiedNamePieceSyntax.self): .qualifiedName, 
      ObjectIdentifier(DeclSyntax.self): .declList, 
      ObjectIdentifier(TypedParameterSyntax.self): .typedParameterList, 
      ObjectIdentifier(ConstructorDeclSyntax.self): .constructorList, 
      ObjectIdentifier(RecordFieldAssignmentSyntax.self): .recordFieldAssignmentList, 
      ObjectIdentifier(ExprSyntax.self): .patternClauseList, 
      ObjectIdentifier(BindingSyntax.self): .bindingList, 
      ObjectIdentifier(BasicExprSyntax.self): .basicExprList, 
      ObjectIdentifier(FunctionClauseDeclSyntax.self): .functionClauseList, 
    ]
  }
}
