import Foundation

extension FileHandle: TextOutputStream {
    public func write(_ string: String) {
        write(string.data(using: .utf8)!)
    }
}

class SwiftGenerator {
  let outputDir: URL
  private var file: FileHandle?
  let nodes: [Node]
  let tokenMap: [String: Token]
  var indentWidth = 0

  init(outputDir: String, nodes: [Node], tokens: [Token]) throws {
    self.outputDir = URL(fileURLWithPath: outputDir)
    self.nodes = nodes
    var tokenMap = [String: Token]()
    for token in tokens {
      tokenMap[token.name] = token
    }
    self.tokenMap = tokenMap
  }

  func write(_ string: String) {
    file?.write(string)
  }

  func line(_ string: String = "") {
    file?.write(String(repeating: " ", count: indentWidth))
    file?.write(string)
    file?.write("\n")
  }

  func writeHeaderComment(filename: String) {
    line("""
    // \(filename)
    // Automatically generated by SyntaxGen. Do not edit!
    //
    // Copyright 2017, The Silt Language Project.
    //
    // This project is released under the MIT license, a copy of which is
    // available in the repository.
    """)
  }

  func generate(_ kind: OutputKind) {
    switch kind {
    case .syntaxKind:
      generateSyntaxKindEnum()
    case .structs:
      generateStructs()
    case .tokenKind:
      generateTokenKindEnum()
    case .batch:
      generate(.syntaxKind)
      generate(.structs)
      generate(.tokenKind)
    }
  }

  func startWriting(to filename: String) {
    let url = outputDir.appendingPathComponent(filename)
    if FileManager.default.fileExists(atPath: url.path) {
        try! FileManager.default.removeItem(at: url)
    }
    FileManager.default.createFile(atPath: url.path, contents: nil)
    file = try! FileHandle(forWritingTo: url)
    writeHeaderComment(filename: filename)
  }

  func generateTokenKindEnum() {
    startWriting(to: "TokenKind.swift")
    line("public enum TokenKind: Equatable {")
    line("  case eof")
    for (_, token) in tokenMap {
      write("  case \(token.caseName.asStandaloneIdentifier)")
      if case .associated(let type) = token.kind {
        write("(\(type))")
      }
      line()
    }
    line()
    line("  public init(punctuation: String) {")
    line("    switch punctuation {")
    for (_, token) in tokenMap {
      guard case .punctuation(let text) = token.kind else { continue }
      line("    case \"\(text)\": self = .\(token.caseName)")
    }
    line("    default: fatalError(\"Not punctuation?\")")
    line("    }")
    line("  }")
    line()
    line("  public init(identifier: String) {")
    line("    switch identifier {")
    for (_, token) in tokenMap {
      guard case .keyword(let text) = token.kind else { continue }
      line("    case \"\(text)\": self = .\(token.caseName)")
    }
    line("    default: self = .identifier(identifier)")
    line("    }")
    line("  }")
    line("  public var text: String {")
    line("    switch self {")
    line("    case .eof: return \"\"")
    for (_, token) in tokenMap {
      write("    case .\(token.caseName)")
      switch token.kind {
      case .associated(_):
        line("(let text): return text.description")
      case .keyword(let text), .punctuation(let text):
        line(": return \"\(text)\"")
      }
    }
    line("    }")
    line("  }")
    line("  public static func == (lhs: TokenKind, rhs: TokenKind) -> Bool {")
    line("    switch (lhs, rhs) {")
    line("    case (.eof, .eof): return true")
    for (_, token) in tokenMap {
      switch token.kind {
      case .associated(_):
        line("    case (.\(token.caseName)(let l), .\(token.caseName)(let r)): return l == r")
      case .keyword(_), .punctuation(_):
        line("    case (.\(token.caseName), .\(token.caseName)): return true")
      }
    }
    line("    default: return false")
    line("    }")
    line("  }")
    line("}")
  }

  func generateSyntaxKindEnum() {
    startWriting(to: "SyntaxKind.swift")
    line("public enum SyntaxKind {")
    line("  case token")
    line("  case unknown")
    for node in nodes {
      line("  case \(node.typeName.asStandaloneIdentifier)")
    }
    line()
    line("  public var syntaxType: Syntax.Type {")
    line("    switch self {")
    line("    case .token: return TokenSyntax.self")
    line("    case .unknown: return Syntax.self")
    for node in nodes {
      line("    case .\(node.typeName.lowercaseFirstLetter): return \(node.typeName)Syntax.self")
    }
    line("    }")
    line("  }")
    line("}")
  }

  func generateStructs() {
    startWriting(to: "SyntaxNodes.swift")
    line("""
      public class ExprSyntax: Syntax {}
      """)
    line("""
      public class DeclSyntax: Syntax {}
      """)
    for node in nodes {
      generateStruct(node)
    }
  }

  func generateStruct(_ node: Node) {
    if let element = node.collectionElement {
      let elementKind = element.contains("Token") ? "Token" : element
      line("""
        public class \(node.typeName)Syntax: SyntaxCollection<\(elementKind)Syntax> {
          public override class var kind: SyntaxKind {
            return .\(node.typeName.lowercaseFirstLetter)
          }
        }
        """)
      line()
      return
    }
    line("public class \(node.typeName)Syntax: \(node.kind)Syntax {")
    if !node.children.isEmpty {
      line("  public enum Cursor: Int {")
      for child in node.children {
        line("    case \(child.name.asStandaloneIdentifier)")
      }
      line("  }")
    }
    line()

    write("  public convenience init(")
    let childParams = node.children
      .map {
        let childKind = $0.kind.contains("Token") ? "Token" : $0.kind
        return "\($0.name): \(childKind)Syntax"
      }
      .joined(separator: ", ")
    write(childParams)
    line(") {")
    line("    let raw = RawSyntax.node(.\(node.typeName.lowercaseFirstLetter), [")
    for child in node.children {
      line("      \(child.name).raw,")
    }
    line("    ], .present)")
    line("    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)")
    line("    self.init(root: data, data: data)")
    line("  }")

    for child in node.children {
      let childKind = child.kind.contains("Token") ? "Token" : child.kind
      line("""
          public var \(child.name): \(childKind)Syntax {
            return child(at: Cursor.\(child.name)) as! \(childKind)Syntax
          }
          public func with\(child.name.uppercaseFirstLetter)(_ syntax: \(childKind)Syntax) -> \(node.typeName)Syntax {
            return data.replacingChild(syntax.raw, at: Cursor.\(child.name))
          }

        """)
    }
    line("}")
    line()
  }
}
